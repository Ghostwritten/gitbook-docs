{"./":{"url":"./","title":"Introduction","keywords":"","body":"序言参考联系公众号序言 这是一本关于集合 Git、Github、Gitlab、Gitbook、gitOps 的书。 参考 Npm Git Github Gitlab Gitbook 温玉 Gitbook 雪之梦 Gitbook 联系 Email: 1zoxun1@gmail.com WeChat: weke59 Youtube: BlackSwanGreen Ins: cnghostwritten Bilibili: LoveDeatRobots 公众号 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-30 12:34:26 "},"Git/":{"url":"Git/","title":"Git","keywords":"","body":"Git 介绍1. 简史2. 简介3. 原理4. 功能5. git 与 SVN 区别6. Git特点6.1 优点6.2 缺点Git 介绍 1. 简史 同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。 Linux 内核开源项目有着为数众多的参与者。 绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002年间）。 到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） 自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统（参见 Git 分支）。 2. 简介 Git 是一个免费和开源的 分布式版本控制系统，旨在以速度和效率处理从小型到大型项目的所有内容。 Git易于学习， 占用空间小，性能快如闪电。它优于 SCM 工具，如 Subversion、CVS、Perforce 和 ClearCase，具有廉价的本地分支、方 便的暂存区域和 多个工作流等功能。 3. 原理 那么，简单地说，Git 究竟是怎样的一个系统呢？ 请注意接下来的内容非常重要，若你理解了 Git 的思想和基本工作原理，用起来就会知其所以然，游刃有余。 在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS、Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。 直接记录快照，而非差异比较 Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方式。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统（CVS、Subversion、Perforce、Bazaar 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 基于差异（delta-based） 的版本控制）。 Figure 4. 存储每个文件与初始版本的差异. Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。 igure 5. 存储项目随时间改变的快照. 这是 Git 与几乎所有其它版本控制系统的重要区别。 因此 Git 重新考虑了以前每一代版本控制系统延续下来的诸多方面。 Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的 VCS。 稍后我们在Git 分支讨论 Git 分支管理时，将探究这种方式对待数据所能获得的益处。 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如果你习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让你感到速度之神赐给了 Git 超凡的能量。 因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。如果你想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 这也意味着你在离线或者没有 VPN 时，几乎可以进行任何操作。 如你在飞机或火车上想做些工作，就能愉快地提交（到你的 本地 副本，还记得吗？）， 直到有网络连接时再上传。如你回家后 VPN 客户端不正常，那么也仍能工作。 使用其它系统的话，做到这些是不可能或很费力的。 比如，用 Perforce 的话，没有连接服务器时几乎不能做什么事；而用 Subversion 和 CVS 的话， 你能修改文件，但不能向数据库提交修改（因为你的本地数据库离线了）。 这样似乎问题不大，但是你可能会惊喜地发现它带来的巨大的不同。 Git 保证完整性 Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据 你执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。 你很难使用 Git 从数据库中删除数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 更深度探讨 Git 如何保存数据及恢复丢失数据的话题，请参考撤消操作。 三种状态 现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。 Figure 6. 工作目录、暂存区域以及 Git 仓库. 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。 如果文件已修改并放入暂存区，就属于 已暂存 状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。 在 Git 基础 一章，你会进一步了解这些状态的细节， 并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 4. 功能 一般开发者的角度来看，git有以下功能： 从服务器上克隆数据库（包括代码和版本信息）到单机上。 在自己的机器上创建分支，修改代码。 在单机上自己创建的分支上提交代码。 在单机上合并分支。 新建一个分支，把服务器上最新版的代码fetch下来，然后跟自己的主分支合并。 生成补丁（patch），把补丁发送给主开发者。 看主开发者的反馈，如果主开发者发现两个一般开发者之间有冲突（他们之间可以合作解决的冲 突），就会要求他们先解决冲突，然后再由其中一个人提交。如果主开发者可以自己解决，或者 没有冲突，就通过。 一般开发者之间解决冲突的方法，开发者之间可以使用pull 命令解决冲突，解决完冲突之后再 向主开发者提交补丁。 从主开发者的角度（假设主开发者不用开发代码）看，git有以下功能： 查看邮件或者通过其它方式查看一般开发者的提交状态。 打上补丁，解决冲突（可以自己解决，也可以要求开发者之间解决以后再重新提交，如果是开源 项目，还要决定哪些补丁有用，哪些不用）。 向公共服务器提交结果，然后通知所有开发人员。 5. git 与 SVN 区别 Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。　　　　 　 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 6. Git特点 6.1 优点 适合分布式开发，强调个体； 公共服务器压力和数据量都不会太大； 速度快、灵活； 任意两个开发者之间可以很容易的解决冲突； 离线工作。 6.2 缺点 代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息； 权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/1_Git_Install.html":{"url":"Git/1_Git_Install.html","title":"1 Git Install","keywords":"","body":"Git 安装1. 简介2. linux 安装2.1 Debian/Ubuntu2.2 Centos/RedHat3. 源码安装4. Windows 安装5. Mac 安装6. Git 配置6.1 用户信息6.2 查看配置Git 安装 1. 简介 Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。 下载地址为：http://git-scm.com/downloads 2. linux 安装 Linux 平台上安装 Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。 在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装： 各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装： 2.1 Debian/Ubuntu $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev $ apt-get install git $ git --version git version 1.8.1.2 2.2 Centos/RedHat $ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel $ yum -y install git-core $ git --version git version 1.7.1 3. 源码安装 ########## Centos/RedHat ########## $ yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel ########## Debian/Ubuntu ########## $ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev $ tar -zxf git-1.7.2.2.tar.gz $ cd git-1.7.2.2 $ make prefix=/usr/local all $ sudo make prefix=/usr/local install 4. Windows 安装 安装包下载地址：https://gitforwindows.org/ 官网慢，可以用国内的镜像：https://npm.taobao.org/mirrors/git-for-windows/。 完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。 在开始菜单里找到\"Git\"->\"Git Bash\"，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 5. Mac 安装 在 Mac 平台上安装 Git 最容易的当属使用图形化的 Git 安装工具，下载地址为： http://sourceforge.net/projects/git-osx-installer/ 安装界面如下所示： 6. Git 配置 Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings\\$USER。 此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 6.1 用户信息 配置个人的用户名称和电子邮件地址： $ git config --global user.name \"ghostWritten\" $ git config --global user.email 1zoxun1@gmail.com 6.2 查看配置 $ git config --list http.postbuffer=2M user.name=ghostWritten user.email=1zoxun1@gmail.com $ git config user.name runoob 这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示： $ vim ~/.gitconfig [http] postBuffer = 2M [user] name = ghostWritten email = 1zoxun1@gmail.com Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/10_Git_Skill.html":{"url":"Git/10_Git_Skill.html","title":"10 Git Skill","keywords":"","body":"Git 技巧Git 技巧 1、git log -p FILE 查看 README.md 的修改历史，例如： > git log -p README.md 2、git log -S’PATTERN’ 例如，搜索修改符合 stupid 的历史： > git log -S'stupid' 3、git add -p 交互式的保存和取消保存变化，使用： > git add -p 4、git rm –cached FILE 这个命令只删除远程文件，例如： > git rm --cached database.yml 删除 database.yml 被保存的记录，但是不影响本地文件。这对删除已经推送过的忽略文件记录而且不影响本地文件是非常的方便的，点击这里送你12个GIT使用技巧。 5、git log ..BRANCH 这个命令返回某个非 HEAD 分支的提交记录。假如你在一个功能分支，输入： > git log ..master 返回全部 master 分支的历史记录，包括未被合并到当前分支的提交记录。 6、git branch –merged & git branch –no-merged Git操作常用的命令都在这里了，点击这里查看。这个命令返回已合并分支列表或未合并的分支列表。这个命令对合并前检查非常有用。例如，在一个功能分支，输入 > git branch --no-merged 返回未合并到该分支的分支列表。 7、git branch –contains SHA 返回包含某个指定 sha 的分支列表。例如： > git branch --contains 2f8e2b 显示全部包含提交 2f832b 的分支。这个命令对于验证 git cherry-pick 完成非常有帮助。 8、git status -s 返回一个简单版的 git status。我设置这个命令为默认 git status 来减少噪音。 > git status -s 9、git reflog 显示你在本地已完成的操作列表。 > git reflog 10、git shortlog -sn 显示提交记录的参与者列表。和GitHub的参与者列表相同。 > git shortlog -sn 11.查看远程仓库 git remote -v 12.从远程获取最新版本到本地 git fetch origin master:temp 13.比较本地的仓库与远程仓库的区别 git diff temp 14.合并temp分支到master分支 git merge temp 如有冲突则需手动解决冲突的文件（git status 能够告诉咱们冲突的文件），而后提交 git add . git commit -m 'conflict fixed' 15.可删除分支 git branch -d temp Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/11_Git_Practice.html":{"url":"Git/11_Git_Practice.html","title":"11 Git Practice","keywords":"","body":"git 实践1. 提交文件1.1 Git 初始化1.2 Git 状态1.3 Git 添加1.4 Git 提交1.5 Git 忽略2. 提交更改2.1 git status2.2 git diff2.3 git add2.4 git diff --staged2.5 git log2.6 git show3. 远程工作3.1 git remote3.2 git push3.3 git pull3.4 git log3.5 git pull4. 撤消更改4.1 git Checkout4.2 git reset4.3 git reset hard4.5 git revert5. 修复合并冲突5.1 git merge（合并）5.2 Viewing Conflict （查看冲突）5.3 resolving conflict（解决冲突）5.4 非快进5.5 git rebase5.6 Rebasing Pull Requests使用分支6.1 git branch6.2 List Branches6.3 Merge To Master（合并到master）6.4 Push Branches（推送分支）6.5 Clean Up Branches7. 查找bug7.1 git diff two Commits7.2 git log7.3 git bisect7.4 git blame7.5 部分提交合并master7.6 Cherry Picking7.7 解决 Cherry-pick冲突7.8 冲突后继续cherry-pick8. Re-writing History(重写历史)8.1 修改提交消息8.2 Squash Commits（组合提交）8.3 Re-order Commits（重新排序提交）8.4 拆分提交git 实践 1. 提交文件 1.1 Git 初始化 $ git init Initialized empty Git repository in /home/scrapbook/tutorial/.git/ $ pwd /home/scrapbook/tutorial 初始化存储库后，会创建一个名为.git的新隐藏子目录。该子目录包含 Git 用于存储其信息的元数据。 1.2 Git 状态 当目录是存储库的一部分时，它被称为工作目录。工作目录包含从存储库下载的最新版本以及尚未提交的任何更改。在您处理项目时，所有更改都在此工作目录中进行。 您可以使用命令查看哪些文件在您的工作目录和之前提交到存储库的文件之间发生了变化 $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) hello-world.js nothing added to commit but untracked files present (use \"git add\" to track) 1.3 Git 添加 要将文件保存或提交到 Git 存储库中，您首先需要将它们添加到暂存区。Git 有三个区域，一个工作目录，一个暂存区和存储库本身。在将更改提交到存储库之前，用户将更改从工作目录移动到暂存区，也称为提升。 Git 的关键方法之一是提交集中、小而频繁。暂存区允许您一次仅提升某些文件而不是工作目录中的所有更改，从而有助于维护此工作流程。 使用该命令git add 将hello-world.js添加到暂存区。 如果您在将文件添加到暂存区后进行其他更改，则在您再次添加文件之前不会反映更改。 1.4 Git 提交 将文件添加到暂存区后，需要将其提交到存储库。该命令git commit -m \"commit message\"将文件从暂存区移动到存储库并记录时间/日期、作者和提交消息，这些消息可用于为更改添加额外的上下文和推理，例如错误报告编号。 只会提交添加到暂存区的更改，不会包含工作目录中尚未暂存的任何文件。 每个提交都分配了一个 SHA-1 哈希值，它使您能够在其他命令中引用回提交。 1.5 Git 忽略 有时，您永远不想提交特定的文件或目录，例如本地开发配置。要忽略这些文件，请在存储库的根目录中创建一个.gitignore文件。 该的.gitignore文件允许你定义通配符您希望忽略，例如*的.tmp将忽略与扩展名为.tmp的所有文件的文件。 任何与定义的通配符匹配的文件都不会显示在git status输出中，并在尝试git add命令时被忽略。 $ echo '*.tmp' > .gitignore $ git add .gitignore $ git commit -m \"gitignore file\" [master (root-commit) 69e1e5a] gitignore file 1 file changed, 1 insertion(+) create mode 100644 .gitignore 2. 提交更改 2.1 git status 当前状态，我们的工作目录中已对先前提交的文件 commit.js 进行了更改，但尚未移动到暂存区。 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: committed.js Untracked files: (use \"git add ...\" to include in what will be committed) untracked.js no changes added to commit (use \"git add\" and/or \"git commit -a\") 2.2 git diff 该命令git diff使您能够将工作目录中的更改与先前提交的版本进行比较。默认情况下，该命令会比较工作目录和HEAD提交。 如果您希望与旧版本进行比较，请提供提交哈希作为参数，例如git diff . 与提交进行比较将输出所有已修改文件的更改。如果要将更改与单个文件进行比较，请提供名称作为参数，例如git diff committed.js. $ git diff committed.js . ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") 默认情况下，输出采用组合差异格式。该命令git difftool将加载您选择的外部工具以查看差异 2.3 git add 与之前的场景一样，为了提交更改，必须首先使用git add命令进行暂存。 $ git add committed.js 如果您重命名或删除文件，则需要在添加命令中指定这些文件以进行跟踪。替代品可以使用git mv，并git rm为混帐要执行的操作，包括更新的临时区域。 2.4 git diff --staged 一旦更改进入暂存区，它们将不会显示在git diff. 默认情况下，git diff将只比较工作目录而不是暂存区。 要将暂存区中的更改与之前的提交进行比较，请提供 staged 参数git diff --staged。这使您能够确保正确地暂存所有更改。 $ git diff --staged ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") 2.5 git log $ git log ESC[33mcommit ddc05ab990a12a81b59a1ca11d68dda2835707e8ESC[mESC[33m (ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:14:41 2021 +0000 Changed the output message in committed.js ESC[33mcommit cfb187d6ebaa88ea358df23c00ff49f6ac8ca7d2ESC[m Author: Katacoda Scenario Date: Thu Nov 4 08:57:27 2021 +0000 Initial Commit 日志输出的格式非常灵活。例如，要在一行上输出每个提交，命令是 $ git log --pretty=format:\"%h %an %ar - %s\" ddc05ab Katacoda Scenario 3 minutes ago - Changed the output message in com cfb187d Katacoda Scenario 20 minutes ago - Initial Commit 可以在使用访问的 git log 手册页中找到更多详细信息git log --help 2.6 git show 虽然 git log 会告诉您提交作者和消息，但要查看提交中所做的更改，您需要使用该命令 $ git show ESC[33mcommit ddc05ab990a12a81b59a1ca11d68dda2835707e8ESC[mESC[33m (ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:14:41 2021 +0000 Changed the output message in committed.js ESC[1mdiff --git a/committed.js b/committed.jsESC[m ESC[1mindex 12e7e7c..fc77969 100644ESC[m ESC[1m--- a/committed.jsESC[m ESC[1m+++ b/committed.jsESC[m ESC[36m@@ -1 +1 @@ESC[m ESC[31m-console.log(\"Committed File\")ESC[m ESC[32m+ESC[mESC[32mconsole.log(\"Demostrating changing a committed file\") (END) 与其他命令一样，默认情况下它将显示 HEAD 提交中的更改。使用git show 查看旧的改变。 3. 远程工作 3.1 git remote 远程存储库允许您共享来自或到您的存储库的更改。远程位置通常是构建服务器、团队成员机器或集中存储，例如 Github.com。使用git remote带有友好名称和远程位置的命令添加远程，通常是 HTTPS URL 或 SSH 连接，例如https://github.com/OcelotUproar/ocelite.git或git@github.com :/OcelotUproar/ocelite。吉特。 友好名称允许您引用其他命令中的位置。您的本地存储库可以根据您的场景引用多个不同的远程存储库。 此环境具有/s/remote-project/1的远程存储库位置。使用git remote，添加这个名为origin 的远程位置。 $ git remote add origin /s/remote-project/1 3.2 git push 当你准备好分享你提交你需要推动他们通过远程仓库git push。典型的 Git 工作流程是在您完成任务并在相关点（例如任务完成时）推送到远程时执行多个小提交，以确保团队内的代码同步。 该git push命令后跟两个参数。第一个参数是我们在第一步中定义的远程存储库的友好名称。第二个参数是分支的名称。默认情况下，所有 git 存储库都有一个主分支，用于处理代码。 $ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 228 bytes | 228.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To /s/remote-project/1 * [new branch] master -> master 将 master 分支中的提交推送到 origin 远程。 3.3 git pull git push允许您将更改推送到远程存储库，git pull以相反的方式工作。git pull允许您将远程存储库中的更改同步到本地版本。 $ git pull origin master remote: Counting objects: 4, done. remote: Compressing objects: 100% (2/2), done. remote: Total 4 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (4/4), done. From /s/remote-project/1 * branch master -> FETCH_HEAD 6292b4d..5bd531a master -> origin/master Updating 6292b4d..5bd531a Fast-forward new-file.txt | 1 + staging.txt | 1 + 2 files changed, 2 insertions(+) create mode 100644 new-file.txt 3.4 git log 如前一场景所述，您可以使用该git log命令查看存储库的历史记录。该git show命令将允许您查看在每次提交中所做的更改。 $ git log ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 ESC[33mcommit 6292b4dc07b6f83180b671d867938288e11a23c5ESC[m Author: Katacoda Scenario Date: Thu Nov 4 09:21:22 2021 +0000 Message $ git show ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 ESC[1mdiff --git a/new-file.txt b/new-file.txtESC[m ESC[1mnew file mode 100644ESC[m ESC[1mindex 0000000..96716fbESC[m ESC[1m--- /dev/nullESC[m ESC[1m+++ b/new-file.txtESC[m ESC[36m@@ -0,0 +1 @@ESC[m ESC[32m+ESC[mESC[32mNewESC[m ESC[1mdiff --git a/staging.txt b/staging.txtESC[m ESC[1mindex c4eb839..b0f03f3 100644ESC[m ESC[1m--- a/staging.txtESC[m ESC[1m+++ b/staging.txtESC[m ESC[36m@@ -1 +1,2 @@ESC[m Staging AreaESC[m ESC[32m+ESC[mESC[32mSomething ChangedESC[m 在此示例中，输出git log显示了“ DifferentUser@JoinScrapbook.com ”的新提交，并带有消息“修复错误 #1234”。的输出git show以绿色突出显示添加到文件中的新行。 $ git log --grep=\"#1234\" ESC[33mcommit 5bd531a9ec87f1fb7b209548f520259c9ab3f93aESC[mESC[33m (ESC[m Author: Different User Date: Thu Nov 4 09:36:48 2021 +0000 Fix for Bug #1234 3.5 git pull 该命令git pull是两个不同命令的组合，git fetch并且git merge. Fetch 将更改从远程存储库下载到名为remotes//的单独分支中。可以使用 访问该分支git checkout。 使用git fetch是一种在不影响当前分支的情况下查看更改的好方法。分支的命名格式足够灵活，您可以拥有多个同名的远程和分支，并在它们之间轻松切换。 以下命令会将获取的更改合并到 master 中。 git merge remotes// master 在原始存储库中进行了其他更改。使用git fetch下载的更改，然后签出的分支进行查看。您可以使用命令查看所有远程分支的列表 git branch -r $ git fetch remote: Counting objects: 2, done. remote: Compressing objects: 100% (2/2), done. remote: Total 2 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (2/2), done. From /s/remote-project/1 5bd531a..7697d4c master -> origin/master $ git checkout remotes/origin/master Note: checking out 'remotes/origin/master'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b HEAD is now at 7697d4c Fix for Bug #42 4. 撤消更改 4.1 git Checkout 使用 Git 时，一个常见的场景是撤消工作目录中的更改。该命令git checkout会将工作目录中的所有内容替换为上次提交的版本。 如果要替换所有文件，请使用点 ( . ) 表示当前目录，否则使用空格分隔的目录/文件列表。 使用git checkout清除工作目录中的任何改变 $ git checkout . 4.2 git reset 如果您正在提交并已将文件添加到暂存区，但后来改变了主意，那么您将需要使用该git reset命令。git reset将文件从暂存区移回工作目录。如果要重置所有文件，请使用. 表示当前目录，否则列出以空格分隔的文件。这在尝试保持提交小而集中时非常有用，因为如果您添加了太多文件，您可以将文件移回暂存区。 使用以下命令将更改从暂存移回工作目录 git reset $ git reset HEAD . Unstaged changes after reset: M staging.txt 4.3 git reset hard git reset --hard将在一个命令中结合 git reset 和 git checkout 。结果将从暂存区中删除文件，并将工作目录恢复到上次提交的状态。 使用以下命令从暂存区和工作目录中删除更改 git reset git reset --hard HEAD 使用HEAD将清除状态回到上次提交，使用git reset --hard 允许您返回到任何提交状态。请记住， HEAD 是分支的最后一个提交哈希的别名。 4.5 git revert 如果您已经提交了文件但意识到自己犯了一个错误，那么该命令 git revert允许您撤消提交。该命令将创建一个新的提交，该提交与被还原的提交具有相反的影响。 如果您尚未推送更改，则git reset HEAD~1具有相同的影响，并将删除最后一次提交。 使用git revert恢复在最后的更改提交。 注意，这将打开一个 Vim 编辑器会话，为每个提交创建一个提交消息。要保存提交消息并退出 vim，请为每个 Vim 会话键入命令:wq。 $ git revert HEAD --no-edit [master 18d0da7] Revert \"Commit To Revert\" Date: Thu Nov 4 11:17:26 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) 创建新提交背后的动机是在 Git 中重写历史是一种反模式。如果你已经推送了你的提交，那么你应该创建新的提交来撤消更改，因为在此期间其他人可能已经提交了。 要一次还原多个提交，我们使用字符~表示减号。例如， HEAD~2 是来自头部的两次提交。这可以与字符组合在一起......在两次提交之间说。 使用该命令git revert HEAD...HEAD~2恢复 HEAD 和 HEAD~2 之间的提交。 $ git revert HEAD...HEAD~2 --no-edit [master 7b75286] Revert \"Revert \"Commit To Revert\"\" Date: Thu Nov 4 11:21:30 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) [master 0aea2ad] Revert \"Commit To Revert\" Date: Thu Nov 4 11:21:30 2021 +0000 1 file changed, 1 insertion(+), 1 deletion(-) 您可以使用该命令git log --oneline快速概览提交历史。 $ git log --oneline ESC[33m0aea2adESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Revert \"Commit To Revert\" ESC[33m7b75286ESC[m Revert \"Revert \"Commit To Revert\"\" ESC[33m18d0da7ESC[m Revert \"Commit To Revert\" ESC[33m9a606a6ESC[m Commit To Revert ESC[33m37ac4b8ESC[m New File ESC[33me263619ESC[m Fixing Error ESC[33md64dc98ESC[m First Commit 5. 修复合并冲突 5.1 git merge（合并） 该git fetch命令将更改下载到可以检出和合并的单独分支中。在合并期间，Git 将尝试自动合并提交。 当不存在冲突时，合并将“快进”，您无需执行任何操作。如果确实存在冲突，那么您将检索错误并且存储库将处于合并状态。 在您的环境中，已从远程存储库获取更改。 您现在需要合并来自 origin/master 的更改。 $ git merge remotes/origin/master fatal: refusing to merge unrelated histories 这将导致合并冲突。冲突表明合并失败，因为两个存储库都添加了该文件。我们将在接下来的步骤中解决此问题。 通过保持提交小而集中，您可以减少合并冲突的可能性。 该命令git pull是一个组合fetch和merge。 5.2 Viewing Conflict （查看冲突） 当发生冲突时，来自本地和远程的更改将以 unix diff 格式出现在同一个文件中。这与git diff使用的格式相同。 要读取格式，本地更改将出现在>>>>之间>> 遥控器/原点/主。 为了解决冲突，需要编辑文件以匹配我们想要的最终状态。我们将在下一步中演示这一点。 Git 支持不同的命令行和可视化合并工具，可以更轻松地解决冲突。该命令git mergetool将启动一个外部工具 5.3 resolving conflict（解决冲突） 解决冲突的最简单方法是使用git checkout --ours staging.txt或选择本地或远程版本git checkout --theirs staging.txt。如果您需要更多控制，那么您可以像平常一样手动编辑文件。 一旦文件处于所需状态，无论是手动还是使用 git checkout，您都需要暂存并提交更改。提交时，将创建默认提交消息，其中包含合并的详细信息和冲突的文件。 通过选择远程更改并使用git add后跟完成合并来解决冲突git commit。 如果您想在合并过程中恢复并重试，请使用该命令git reset --hard HEAD;返回到之前的状态。 使用git commit --no-edit时要使用的默认提交信息。 $ git checkout --theirs staging.txt $ git add staging.txt $ git commit --no-edit On branch master nothing to commit, working tree clean 5.4 非快进 为了模拟非快进合并，发生了以下情况。 1) 开发人员 A 从开发人员 B 拉取最新更改。 2) 开发人员 B 将更改提交到其本地存储库。 3) 开发人员 A 向其本地存储库提交无冲突的更改。 4) 开发人员 A 从开发人员 B 那里提取最新的更改。 在这种情况下，Git 无法快进来自开发人员 B 的更改，因为开发人员 A 进行了许多更改。 发生这种情况时，Git 将尝试自动合并更改。如果不存在冲突，则合并将完成，并且将创建一个新的提交以指示在该时间点发生的合并。 合并的默认提交消息是“合并分支”' 的 \"。这些提交可用于指示存储库之间的同步点，但也会产生嘈杂的提交日志。在下一步中，我们将研究替代方法。 从远程存储库中提取更改并使用以下命令使用默认提交消息。 $ git pull --no-edit origin master remote: Counting objects: 4, done. remote: Compressing objects: 100% (4/4), done. remote: Total 4 (delta 1), reused 0 (delta 0) Unpacking objects: 100% (4/4), done. From /s/remote-project/1 * branch master -> FETCH_HEAD d0ab773..654bdfd master -> origin/master fatal: refusing to merge unrelated histories $ git log --all --decorate --oneline ESC[33ma7312c0ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Fix for Bug #55 ESC[33m654bdfdESC[mESC[33m (ESC[mESC[1;31morigin/masterESC[mESC[33m)ESC[m Fix for Bug #58a ESC[33m3074197ESC[m Fix for Bug #58 ESC[33mdce3e2aESC[m Fixing Error ESC[33md0ab773ESC[m Fix for Bug #1234 ESC[33mf7126daESC[m First Commit 5.5 git rebase 合并提交消息可用于指示同步点，但它们也会产生大量垃圾信息。例如，如果您正在针对本地分支工作并且尚未推送，那么对于查看存储库的其他开发人员而言，这些附加信息毫无意义且令人困惑。 要解决此问题，您可以使用git rebase代替git merge. 变基将取消您所做的更改并重播分支中的更改，应用您的更改，就好像它们都发生在同一个分支上一样。结果是合并的干净历史记录和图表。 重要由于rebase将重播更改而不是合并，每个提交将有一个新的哈希 id。如果您或其他开发人员推/拉了存储库，则更改历史记录可能会导致 git 丢失提交。因此，您不应该对已公开的提交进行 rebase，例如推送提交，然后 rebase 来自不同分支的旧提交。结果将是具有不同哈希 ID 的先前公开提交 5.6 Rebasing Pull Requests 这种方法在使用远程分支时也适用，并且可以在使用以下方式发出拉取请求时应用： git pull --rebase 这就像您在每次提交之前完成了拉取请求一样。 使用分支 6.1 git branch branch分支是基于另一个分支创建的，通常是 master。该命令git branch 采用现有分支并创建一个单独的分支来工作。此时两个分支是相同的。 要切换到分支，请使用该git checkout 命令。 $ git branch new_branch master $ git checkout new_branch Switched to branch 'new_branch' 6.2 List Branches $ git branch masterESC[m * ESC[32mnew_branchESC[m 附加参数-a将包括远程分支，而包括-v将包括分支的 HEAD 提交消息 $ git branch -va master ESC[m b54bcf8 First Commit on master * ESC[32mnew_branchESC[m a6eb09c Commit on branch 6.3 Merge To Master（合并到master） 已提交到新分支。要将其合并到master 中，您首先需要检出目标分支，在本例中为 master，然后使用 'git merge' 命令合并来自分支的提交。 $ git checkout master Switched to branch 'master' $ git merge new_branch Updating b54bcf8..8eb1a99 Fast-forward new-file-6.txt | 1 + staging.txt | 2 +- 2 files changed, 2 insertions(+), 1 deletion(-) create mode 100644 new-file-6.txt 6.4 Push Branches（推送分支） 如果你想将一个分支推送到远程，那么使用命令 git push 6.5 Clean Up Branches 清理分支对于消除噪音和混乱很重要。要删除您需要提供参数的一个分支-d，例如git branch -d 7. 查找bug 7.1 git diff two Commits 该git diff命令是比较提交之间更改的最简单的命令。它将输出两次提交之间的差异。 您可以通过提供两次提交的哈希 ID 或指针（blob）来直观地进行任何两次提交 $ git diff HEAD~2 HEAD ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,6 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m 7.2 git log 虽然git log可以帮助您查看提交消息，但默认情况下它不会输出实际更改的内容。值得庆幸的是，该命令非常灵活，附加选项提供了对存储库历史的有用见解。 要在简短的视图中查看提交的概述，请使用命令 $ git log --oneline ESC[33mbb37e28ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[m Final Item ESC[33md029598ESC[m New Item ESC[33ma097903ESC[m Initial commit of the list 要输出具有更改内容差异的提交信息，您需要包含-p提示，例如 $ git log -p ESC[33mcommit bb37e28391de9e741c2852396c5e16ea38bc0d06ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[ Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 Final Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex def310d..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -3,4 +3,5 @@ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m ESC[33mcommit d029598d9d0fbd6fcf73133eeee75217d0ecfeebESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 New Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..def310d 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,5 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[m ESC[33mcommit a097903bb0c59689c6cd853943e073e92e18f1d6ESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 这将输出整个历史。您可以使用许多不同的选项对其进行过滤。所述-n 指定从HEAD提交至显示器的限制。例如 git log -p -n 2显示 HEAD 和 HEAD~1。 $ git log -p -n 2 ESC[33mcommit bb37e28391de9e741c2852396c5e16ea38bc0d06ESC[mESC[33m (ESC[mESC[1;36mHEAD -> ESC[mESC[1;32mmasterESC[mESC[33m)ESC[ Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 Final Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex def310d..9f53aec 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -3,4 +3,5 @@ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[32m+ESC[mESC[32mPraesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat ESC[m ESC[33mcommit d029598d9d0fbd6fcf73133eeee75217d0ecfeebESC[m Author: Katacoda Scenario Date: Thu Nov 4 11:55:52 2021 +0000 New Item ESC[1mdiff --git a/list.html b/list.htmlESC[m ESC[1mindex 96e99d0..def310d 100644ESC[m ESC[1m--- a/list.htmlESC[m ESC[1m+++ b/list.htmlESC[m ESC[36m@@ -2,4 +2,5 @@ESC[m Lorem ipsum dolor sit amet, consectetuer adipiscing elit.ESC[m Aliquam tincidunt mauris eu risus.ESC[m Vestibulum auctor dapibus neque.ESC[m ESC[32m+ESC[mESC[32mMorbi in sem quis dui placerat ornare. Pellentesque odio nisi, euismod in, pharetra a.ESC[m ESC[m 如果您知道时间段，那么您可以使用--since=\"2 weeks ago\"和 __--until=\"1 day ago\"在特定日期之前的提交之间使用时间段。 使用该命令git log --grep=\"Initial\"将输出在其提交消息中包含“Initial”一词的所有提交。如果您使用错误跟踪编号标记提交，这将非常有用。 正如我们在合并场景中所讨论的，由于使用合并通知提交，您的提交历史可能会变得嘈杂。要删除它们，请使用 git log提供参数-m。 7.3 git bisect 这些git bisect命令允许您对存储库进行二进制搜索，以查找哪个提交引入了问题和回归。在这一步中，我们将在 list.html 中找到忘记 HTML 标签的提交。 Git bisect 需要很多步骤，执行这些步骤才能看到结果。 要进入二等分模式，请使用命令git bisect start。这表明它包含您在引入时要搜索的问题。 我们已经定义了错误提交发生的位置，现在需要定义上次已知的良好提交何时使用git bisect good HEAD~5.在这种情况下，它是五次提交前。 第 3 步将检出坏提交和好的提交之间的提交。然后，您可以检查提交、运行测试等以查看错误是否存在。在本例中您可以使用cat list.html 这个提交看起来不错，因为一切都有正确的 HTML 标签。我们告诉 Git 我们很高兴使用git bisect good.这将自动检查在最后一次已知的良好提交中间的提交，如步骤 5 和我们的错误提交中所定义。 正如我们之前所做的那样，我们需要检查提交是好是坏。 cat list.html 此提交缺少 HTML 标签。usinggit bisect bad将结束搜索并输出相关的提交 ID。 7.4 git blame 虽然“责备”文化是不可取的，但了解谁在文件的某些部分工作以帮助将来进行改进可能会很有用。这是git blame可以提供帮助的地方。 git blame 显示最后修改文件每一行的修订版和作者。 在文件上运行blame将输出谁最后接触每一行。 $ git blame list.html ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 1) ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 2) Lorem ipsum dolor sit amet, consectetuer adipiscing elit. ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 3) Aliquam tincidunt mauris eu risus. ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 4) Vestibulum auctor dapibus neque. d029598d (Katacoda Scenario 2021-11-04 11:55:52 +0000 5) Morbi in sem quis dui placerat ornare. Pellentesque odio nisi, eui bb37e283 (Katacoda Scenario 2021-11-04 11:55:52 +0000 6) Praesent dapibus, neque id cursus faucibus, tortor neque egestas a 1958fba4 (Katacoda Scenario 2021-11-04 12:14:30 +0000 7) Vestibulum auctor dapibus neque ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 8) 如果我们知道我们关心的行，那么我们可以使用-L参数来提供要输出的行范围。 $ git blame -L 6,8 list.html bb37e283 (Katacoda Scenario 2021-11-04 11:55:52 +0000 6) Praesent dapibus, neque id cursus faucibus, tortor neque egestas a 1958fba4 (Katacoda Scenario 2021-11-04 12:14:30 +0000 7) Vestibulum auctor dapibus neque ^a097903 (Katacoda Scenario 2021-11-04 11:55:52 +0000 8) 7.5 部分提交合并master 小提交的优点之一是您可以挑剔要合并的内容。 这个问题特别涉及长期存在的分支，这些分支已经与主分支过时，导致太多冲突而无法简单地合并。这在非常活跃的开源项目中很常见。 发生这种情况时，您希望能够挑选出单独的提交并将它们合并到主分支中。 该环境已配置了一个存储库，其中包含在单独的分支中开发的 HTML 列表。在这种情况下，我们将从这个分支中选择某些我们想要在 master 中结束的提交。 7.6 Cherry Picking 在这种情况下，我们在 _new分支中有许多提交，它创建了两个 html 文件。在这种情况下，我们只关心对其中一个文件的更改，但是如果我们合并了分支，那么我们将合并所有五个提交和不需要的更改。 要合并单个提交，我们使用该git cherry-pick 命令。这与merge 的行为方式类似，如果不存在冲突，则提交将自动合并。 按照以下步骤合并我们感兴趣的三个提交。我们希望按照它们在原始存储库中发生的顺序重放提交。 选择带有消息“初始提交，无项目”的提交 用“初始列表”消息挑选提交 选择带有消息“将最终项目添加到列表中”的提交 我们之前使用过 HEAD 来指示当前分支的尖端。您可以使用语法 跨分支引用~#。例如，new_branch~3指的是分支中倒数第二个提交，在这种情况下，它具有提交消息“初始提交，没有项目” 7.7 解决 Cherry-pick冲突 以同样的方式，合并会导致冲突，Cherry Picking也会导致冲突。您解决以同样的方式冲突与手动或者合并一个分支固定的文件或选择他们或者我们通过git checkout。 如果你觉得你犯了一个错误，你可以停止并使用git cherry-pick --abort Cherry-pick第二个列表的创建使用 git cherry-pick new_branch~1 这将导致合并冲突。使用git checkout并选择选择的提交解决冲突。 准备好后继续，我们将完成cherry pick。 git cherry-pick new_branch~1 git status git diff git checkout --theirs list2.html 7.8 冲突后继续cherry-pick 解决冲突后，您可以使用命令继续进行cherry pick git cherry-pick --continue。 与使用merge类似，解决cherry-pick 将导致提交。 首先添加先前冲突的项目，然后使用--continue选项来完成樱桃选择。 $ git add list2.html $ git cherry-pick --continue [master d95af12] q :q! q q Date: Thu Nov 4 12:40:46 2021 +0000 1 file changed, 4 insertions(+), 1 deletion(-) 此时，默认编辑器（在本例中为 vim）将弹出，允许您编辑精心挑选的提交消息，以包含冲突的详细信息及其解决方式。要保存和退出 vim 类型：wq 8. Re-writing History(重写历史) Git 的一个重要方面是您保持存储库和历史记录的干净程度。一个干净的存储库更容易使用和理解发生了什么。 此场景将介绍如何使用 Rebase 重写 Git 历史记录以重构提交，以确保在推送更改之前它们是可理解的。您应该只重新设置未通过推送与其他人共享的提交。重新提交提交会导致他们的提交 ID 发生变化，这可能会导致丢失未来的提交。 8.1 修改提交消息 使用git rebase -interactive. 通过将 rebase 置于交互模式，您可以更好地控制要进行的更改。启动到交互模式后，您将获得六个命令来执行存储库中的每个提交。通过使用 Vim 默认打开的编辑器，您可以定义要在每次提交时执行的操作。 在这个例子中，我们想要改变提交。要将其置于此状态，我们需要更改提交旁边的单词“pick”以匹配基于 Vim 窗口中显示的列表要执行的操作，在本例中为“reword”。 在本例中，我们要更改提交消息。 首先，我们需要使用以下命令进入 Interactive Rebase 模式 git rebase --interactive --root 开始使用 Vim 可能有点令人困惑，要编辑文本，您首先需要输入i，这将使您进入“插入模式”。 我们想编辑第一条提交消息“列表的初始提交”中的“提交”错字。对于提交，更改单词“pick”以匹配我们要在提交时执行的命令，在本例中为“reword”。 要保存并退出，请按esc键然后:wq。这将打开另一个 Vim 编辑器窗口。 再次使用 Vim，编辑提交消息以将“comit”更改为“commit”。保存并退出 Vim 后，您将看到 Git 更改提交的输出。使用git log --oneline以查看更新的提交信息。 该--root参数可以让你变基在库中的所有提交，其中包括第一次提交。 更改上次提交消息的更快替代方法是git commit --amend使用 Vim 进行更改。 8.2 Squash Commits（组合提交） 在您的本地环境中进行了一系列 8 次不同的提交。当时这些提交是有意义的，但现在它们只需要一次提交。衍合使用，我们需要压扁的提交在一起。 使用git rebase --interactive HEAD~8，我们有从 HEAD 到最后 0 的提交范围。要压缩我们需要一个基本提交，所有内容都将被压缩到其中。因此，将第一个提交保留为“pick”，但将其余提交更改为“squash”。 保存后，您将有机会进行编辑。默认情况下，Git 提交消息将是先前压缩的提交消息的组合。 当我们进入 Interactive Rebase 时，我们可以指定我们要使用以下命令修改前 8 次提交 git rebase --interactive HEAD~8 在前一阶段，我们使用了reword。这里我们要使用壁球。我们想将 8 个提交压缩为一个，如果我们将所有提交标记为压缩，那么我们会收到错误“不能在没有先前提交的情况下‘压缩’”，因为没有一个基本提交来压缩所有内容。 为了压缩提交，我们需要将第一个提交作为我们的基础，并用squash标记以下 7 。 在保存和退出 Vim 时，我们会看到一个新的 Vim 窗口，其中列出了 rebase 中 8 条提交消息的组合。 保存提交消息后，历史将被修改。你可以看到这个使用git log --在这里插入代码片oneline 8.3 Re-order Commits（重新排序提交） 我们想重新排序我们的最后两个提交。使用HEAD~2允许我们修改它们。 git rebase --interactive HEAD~2 使用 Vim，只需重新排列行，保存并退出，提交将匹配顺序。 8.4 拆分提交 就像压缩提交一样，有时将更改从提交中分离出来是很有用的，以便让它们保持专注并使挑选或恢复更容易。 拆分提交是一个两个阶段的过程。首先，我们需要定义要拆分的提交，然后需要定义新提交的外观。 1.定义拆分提交 在这里，我们要拆分之前的提交。我们使用git rebase --interactive HEAD~1 与之前的变基一样，我们需要将任务更改为编辑 我们现在处于交互式编辑历史的状态。Git 将记录所有更改，最终结果将应用于存储库。 2.拆分提交 在定义我们要编辑提交后，我们现在处于允许我们更改历史记录的状态。 由于我们想要拆分现有提交，因此我们首先需要使用git reset HEAD^. 提交已被删除，但文件仍然存在。我们现在可以按照我们以前的意愿执行提交，作为两个单独的操作。 执行命令： git add file3.txt git commit -m \"File 3\" git add file4.txt git commit -m \"File 4\" 一旦对存储库的状态感到满意，我们就会告诉 Git 继续 rebase 并使用--continue更新存储库。 git rebase --continue 您可以使用以下命令查看输出和两个新提交 git log --oneline 官方文档 https://git-scm.com/book/en/v2/Getting-Started-Installing-Git Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/12-Git_Set_upstream_branch.html":{"url":"Git/12-Git_Set_upstream_branch.html","title":"12 Git Set Upstream Branch","keywords":"","body":"Git 如何设置上游分支 upstream？1. 背景2. 准备3. 什么是 Git 上游分支（upstream）？4. 如何在 Git 中设置上游分支5. 使用 Git Push 命令设置上游分支6. 如何在 Git 中更改上游分支7. 如何检查哪些 Git 分支正在跟踪哪些上游分支Git 如何设置上游分支 upstream？ 1. 背景 当您想要克隆一个新的存储库或使用各种功能分支时，您需要知道如何使用上游分支以及如何设置它们。本文将告诉您如何设置上游分支，它还会告诉您哪个 git 本地分支正在跟踪哪个上游远程分支。 2. 准备 在本地计算机上安装并配置 Git。 本地存在克隆的 Git 存储库或您自己的 Git 项目 3. 什么是 Git 上游分支（upstream）？ 当您想从远程存储库（如 GitHub 或 Bitbucket）检出 git 中的分支时，“上游分支”是托管在 Github 或 Bitbucket 上的远程分支。每当您发出基本上没有参数的普通 git fetch/git pull 时，它就是您从中获取/拉出的分支。 4. 如何在 Git 中设置上游分支 对上游分支使用带有“-u”选项的 Git Push 命令。 5. 使用 Git Push 命令设置上游分支 创建一个名为“的新分支并使用-b选项切换到当前分支 创建一个名为“的新分支并使用-b选项切换到当前分支 git checkout -b 切换分支确认出现如下： 当当前分支（'new_branch'）没有设置上游分支时，我们尝试运行命令“Git push”。在cmd中运行以下命令后： 现在，您需要使用带有 -u 选项的 Git push 命令来设置上游分支。将 替换为您的分支名称。 git push -u origin 或者，您也可以使用“–set-upstream”命令来设置上游分支 git push --set-upstream origin 6. 如何在 Git 中更改上游分支 现在，您需要跟踪一个新的上游分支而不是刚刚设置运行的分支： git branch -u git branch main -u git branch main -u 终端打印出确认消息： 7. 如何检查哪些 Git 分支正在跟踪哪些上游分支 现在，您可以使用带有 -vv 选项的“Git 分支”列出所有跟踪上游分支的分支： 主分支有一个 [origin/main] 的跟踪分支。测试分支有一个跟踪分支[origin/test]。new_branch 分支有一个跟踪分支[origin/new_branch]。 参考： How to Set Upstream Branch on Git? Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2023-02-22 08:55:44 "},"Git/13_Git_fetch_and_pull_difference.html":{"url":"Git/13_Git_fetch_and_pull_difference.html","title":"13 Git Fetch And Pull Difference","keywords":"","body":"Git Fetch 和 Git Pull 的区别1. 介绍2. Git Fetch3. Git Pull4. 结论Git Fetch 和 Git Pull 的区别 1. 介绍 Git Fetch 是一个命令，它告诉本地存储库远程存储库中有可用的更改，而不会将更改带入本地存储库。另一方面，Git Pull 将远 程目录更改的副本带入本地存储库。让我们借助示例分别查看 Git Fetch 和 Git Pull。 git pull = git fetch + git merge 2. Git Fetch 让我们创建一个名为demo.txt的文件，其中包含“ Hello Geeks”内容，将目录初始化为 git 存储库，并将更改推送到远程存储库。 git init git add git commit -m git remote add origin git push origin 现在，我们在远程存储库中 有了我的demo.txt 。 本地和远程存储库现在是同步的，并且在两个地方具有相同的内容。现在让我们更新远程存储库中的 demo.txt 。 现在，由于我们已经远程更新了demo.txt，让我们将更改带到我们的本地存储库。我们的本地存储库只有 1 次提交，而远程存储库现在 有 2 次提交（观察从4c4fcb8开始的第二次提交）。让我们使用git fetch命令在本地存储库中查看远程存储库中是否有更改。在此 之前，让我们使用git log命令查看我们之前的提交。 我们可以看到，在使用git fetch之后，我们得到了在远程存储库中完成了一些提交的信息。（注意4c4fcb8是我们在远程存储库中第二次提交的首字母）。要将这些更改合并到我们的本地存储库中，我们需要使用git merge origin/命令。 让我们使用git log 命令查看我们在本地存储库中的提交。 我们在本地存储库中提交了远程存储库。这就是 git fetch 的工作原理。现在让我们看一下git pull命令。 3. Git Pull 让我们对远程存储库中的 demo.txt 文件进行更多更改。 现在，我们在远程存储库中有 3 个提交，而在我们的本地存储库中有 2 个提交。（注意以09d828f开头的第三次提交）。现在让我们使 用git pull origin 命令将此更改带到我们的本地存储库。 我们可以看到，在git pull命令的帮助下，我们直接获取远程存储库并将其与本地存储库合并。 4. 结论 git pull = git fetch + git merge 现在我们的远程和本地存储库再次相互同步。因此，从以上例子中，我们可以得出结论： |Git fetch |Git pull| |--|--| |在不合并到当前分支的情况下提供来自远程存储库的新更改的信息| 从远程存储库中获取所有更改的副本并将它们合并到当前分支中| |存储库数据在 .git 目录中更新| 直接更新本地仓库| |可以审查提交和更改 |立即将更改更新到本地存储库。| |没有合并冲突的可能性。 |如果远程和本地存储库在同一位置进行了更改，则可能会发生合并冲突。| |Git fetch 的命令是 git fetch |Git Pull 的命令是 git pull| |Git fetch 基本上将提交导入到本地分支，以便及时了解每个人正在处理的内容。| Git Pull 基本上使本地分支与远程副本一起 更新，远程副本也将更新其他远程跟踪分支。| 参考： Git – Difference Between Git Fetch and Git Pull Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2023-02-22 08:56:21 "},"Git/14_Git_fetch_prune.html":{"url":"Git/14_Git_fetch_prune.html","title":"14 Git Fetch Prune","keywords":"","body":"Git remote prune、Git prune 和 Git fetch –prune 的区别1. 背景2. 方法Git remote prune、Git prune 和 Git fetch –prune 的区别 1. 背景 Git 的一大优点是它在删除数据时非常小心。这使得 Git 中的提交或其他有价值的数据很难丢失！这样做的一个小缺点是您有时可能 会看到实际上不再需要的陈旧数据。最好的例子之一是对已删除的远程分支的引用：假设您的一位队友删除了共享远程存储库中的一个分支；该分支仍会为您显示，除非您明确指示 Git 进行清理。 2. 方法 在远程存储库上使用“prune”： “prune”可作为 git fetch 和 git remote 命令的选项使用。（git prune 命令——在垃圾收集期间使用。）。使用 prune 的最简 单方法是在获取时将其作为选项提供： git fetch --prune origin 如果您只想*执行prune而不*获取远程数据，您可以将它与 git remote 一起使用： git remote prune origin 两种情况下的结果是相同的：对指定远程存储库中不再存在的远程分支的陈旧引用将被删除。顺便说一句：你永远不必担心你当地的分支机构，因为修剪永远不会影响那些。 克隆同一个 repo 两次，以便您正确理解 git prune 的工作原理。 git clone repolink 在一个回购上创建一个分支并在其副本上获取它 从一个回购中删除该分支 当您在另一个仓库中列出分支时，它不会得到更新。 git branch git push origin HEAD git branch -r 使用 git fetch –prune： 如果我们使用 prune 命令删除，该分支将在 2nd repo 中自动更新 git fetch --prune 假设在某些情况下您希望*只*执行prune并且不获取远程数据 git remote prune origin 如果你想自动prune自己 git config —global fetch.prune true 参考： Difference Between Git remote prune, Git prune and Git fetch –prune Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2023-02-22 08:56:47 "},"Git/2_Git_Process.html":{"url":"Git/2_Git_Process.html","title":"2 Git Process","keywords":"","body":"Git 流程Git 流程 一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/3_Git_Concept.html":{"url":"Git/3_Git_Concept.html","title":"3 Git Concept","keywords":"","body":"Git 概念Git 概念 我们先来理解下 Git 工作区、暂存区和版本库概念： 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage/index），标记为 \"master\" 的是master 分支所代表的目录树。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 git rm --cached 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 git checkout -- 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。 当执行 git checkout HEAD . 或者 git checkout HEAD 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/4_Git_Branch_Management.html":{"url":"Git/4_Git_Branch_Management.html","title":"4 Git Branch Management","keywords":"","body":"Git 分支管理1. 简介2. Git 分支管理2.1 列出分支2.2 创建分支2.3 切换分支2.4 删除分支2.5 分支合并2.6 合并冲突Git 分支管理 1. 简介 几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。 使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 开始前我们先创建一个测试目录： $ mkdir gitdemo $ cd gitdemo/ $ git init Initialized empty Git repository... $ touch README $ git add README $ git commit -m '第一次版本提交' [master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README 2. Git 分支管理 2.1 列出分支 列出分支基本命令： git branch 没有参数时，git branch 会列出你在本地的分支。 $ git branch * master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。 当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。 2.2 创建分支 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 $ git branch testing $ git branch * master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。 2.3 切换分支 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 $ ls README $ echo 'runoob.com' > test.txt $ git add . $ git commit -m 'add test.txt' [master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch 'testing' $ ls README 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。 $ git checkout master Switched to branch 'master' $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。 $ git checkout -b newtest Switched to a new branch 'newtest' $ git rm test.txt rm 'test.txt' $ ls README $ touch runoob.php $ git add . $ git commit -am 'removed test.txt、add runoob.php' [newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt $ ls README runoob.php $ git checkout master Switched to branch 'master' $ ls README test.txt 你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。 使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。 2.4 删除分支 删除分支命令： git branch -d (branchname) 例如我们要删除 testing 分支： $ git branch * master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch * master 2.5 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： git merge $ git branch * master newtest $ ls README test.txt $ git merge newtest Updating 3e92c19..c1501a2 Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt $ ls README runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。 合并完后就可以删除分支: $ git branch -d newtest Deleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： $ git branch * master 2.6 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。 $ git branch * master $ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为: 创建 change_site 分支： $ git checkout -b change_site Switched to a new branch 'change_site' $ vim runoob.php $ head -3 runoob.php $ git commit -am 'changed the runoob.php' [change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。 $ git checkout master Switched to branch 'master' $ cat runoob.php $ vim runoob.php # 修改内容如下 $ cat runoob.php $ git diff diff --git a/runoob.php b/runoob.php index e69de29..ac60739 100644 --- a/runoob.php +++ b/runoob.php @@ -0,0 +1,3 @@ + $ git commit -am '修改代码' [master c68142b] 修改代码 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 \"master\" 分支了。接下来我们将 \"change_site\" 分支合并过来。 $ git merge change_site Auto-merging runoob.php CONFLICT (content): Merge conflict in runoob.php Automatic merge failed; fix conflicts and then commit the result. $ cat runoob.php # 打开文件，看到冲突内容 >>>>>> change_site ?> 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。 $ vim runoob.php $ cat runoob.php $ git diff diff --cc runoob.php index ac60739,b63d7d7..0000000 --- a/runoob.php +++ b/runoob.php @@@ -1,3 -1,3 +1,4 @@@ 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决 $ git status -s UU runoob.php $ git add runoob.php $ git status -s M runoob.php $ git commit [master 88afe0e] Merge branch 'change_site' Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/5_Git_View_Commit_History.html":{"url":"Git/5_Git_View_Commit_History.html","title":"5 Git View Commit History","keywords":"","body":"Git 查看提交历史1. git log2. git blameGit 查看提交历史 Git 提交历史一般常用两个命令： git log - 查看历史提交记录。 git blame - 以列表形式查看指定文件的历史修改记录。 1. git log 在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下： $ git log commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -> master) Merge: c68142b 7774248 Author: runoob Date: Fri May 3 15:55:58 2019 +0800 Merge branch 'change_site' commit c68142b562c260c3071754623b08e2657b4c6d5b Author: runoob Date: Fri May 3 15:52:12 2019 +0800 修改代码 commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site) Author: runoob Date: Fri May 3 15:49:26 2019 +0800 changed the runoob.php commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00 Author: runoob Date: Fri May 3 15:35:32 2019 +0800 我们可以用 --oneline 选项来查看历史记录的简洁的版本。 $ git log --oneline d5e9fc2 (HEAD -> master) Merge branch 'change_site' c68142b 修改代码 7774248 (change_site) changed the runoob.php c1501a2 removed test.txt、add runoob.php 3e92c19 add test.txt 3b58100 第一次版本提交 这告诉我们的是，此项目的开发历史。 我们还可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： $ git log `--graph * d5e9fc2 (HEAD -> master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。 你也可以用 --reverse 参数来逆向显示所有日志。 $ git log --reverse --oneline 3b58100 第一次版本提交 3e92c19 add test.txt c1501a2 removed test.txt、add runoob.php 7774248 (change_site) changed the runoob.php c68142b 修改代码 d5e9fc2 (HEAD -> master) Merge branch 'change_site' 如果只想查找指定用户的提交日志可以使用命令：git log --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分： $ git log --author=Linus --oneline -5 81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory 3bb7256 make \"index-pack\" a built-in 377d027 make \"git pack-redundant\" a built-in b532581 make \"git unpack-file\" a built-in 112dd51 make \"mktag\" a built-in 如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 --no-merges 选项以隐藏合并提交）： $ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges 5469e2d Git 1.7.1-rc2 d43427d Documentation/remote-helpers: Fix typos and improve language 272a36b Fixup: Second argument may be any arbitrary string b6c8d2d Documentation/remote-helpers: Add invocation section 5ce4f4e Documentation/urls: Rewrite to accomodate transport::address 00b84e9 Documentation/remote-helpers: Rewrite description 03aa87e Documentation: Describe other situations where -z affects git diff 77bc694 rebase-interactive: silence warning when no commits rewritten 636db2c t3301: add tests to use --format=\"%N\" 2. git blame 如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下： git blame git blame 命令是以列表形式显示修改记录，如下实例： $ git blame README ^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) db9315b0 (runoob 2020-08-25 16:00:23 +0800 2) Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/6_Git_Tag.html":{"url":"Git/6_Git_Tag.html","title":"6 Git Tag","keywords":"","body":"Git 标签Git 标签 如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。 比如说，我们想为我们的 runoob 项目发布一个\"1.0\"版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）\"v1.0\"的标签。 -a 选项意为\"创建一个带注解的标签\"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。 $ git tag -a v1.0 当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 现在，注意当我们执行 git log --decorate 时，我们可以看到我们的标签了： * d5e9fc2 (HEAD -> master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 第一次版本提交 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * d5e9fc2 (HEAD -> master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 (tag: v0.9) 第一次版本提交 如果我们要查看所有标签可以使用以下命令： $ git tag v0.9 v1.0 指定标签信息命令： git tag -a -m \"runoob.com标签\" PGP签名标签命令： git tag -s -m \"runoob.com标签\" Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/7_Git_Password-free_Login.html":{"url":"Git/7_Git_Password-free_Login.html","title":"7 Git Password Free Login","keywords":"","body":"Git 免密登录邮箱可以随便填Git 免密登录 许多Git服务器都支持使用SSH公钥进行认证，当然也包括github。 首先你需要确认一下自己是否已经拥有密钥了，默认情况下，用户的 SSH 密钥存储在其 ~/.ssh 目录下。进入该目录并列出其中内容，你便可以快速确认自己是否已经拥有密钥： $ cd ~/.ssh $ ls authorized_keys2 id_rsa known_hosts config id_rsa.pub 我们需要寻找一对 id_rsa 或 id_dsa 命名的文件，其中一个带 .pub 扩展名。 '.pub'文件是你的公钥，另一个则是私钥。如果没有找不到这样的文件（或者根本就没有.ssh目录），我们可以通过 ssh-keygen 程序来创建它们。 邮箱可以随便填 $ ssh-keygen -t rsa -C \"xx@xx.com\" 首先 ssh-keygen 会确认密钥的存储位置和文件名（默认是 .ssh/id_rsa）,然后他会要求你输入两次密钥口令，留空即可。所以一般选用默认，全部回车即可。 接下来我们登陆到GitHub上，右上角小头像->Setting->SSH and GPG keys中，点击new SSH key。 Title：可以随便填写，但最好起的名字能让自己知道这个公钥是哪个设备的。 Key：将上面生成的.pub文件中的所有内容复制到这里。 点击下面的Add SSH key即可。 然后你就会发现可以免密码访问了 Git服务器 如果服务端是自己搭建的git服务器，生成密钥公钥对的步骤是一样的。 然后将生成的 .pub 文件内容，导入到git服务器 /home/git/.ssh/authorized_keys 文件内，一行一个。 然后你就会发现git push 不再需要密码了 搭建git服务器和相关免登陆的详细步骤可参考我的另一篇 手把手教你搭建git服务器 HTTPS通信协议 上面讲了SSH方式的免密码，接下来讲一下越来越常用的HTTPS方式的免密码 新建文件并保存密码 $ touch ~/.git-credentials $ vim ~/.git-credentials https://{username}:{passwd}@github.com 添加git配置 $ git config --global credential.helper store 查看～/.gitconfig文件变化 $ cat ～/.gitconfig [credential] helper = store 然后在尝试一下git push不再在需要密码了 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/8_Git_Rollback.html":{"url":"Git/8_Git_Rollback.html","title":"8 Git Rollback","keywords":"","body":"git 回滚git 回滚 查看所有commits记录 $ git log commit 261bbc7e909c37b877595560bb04613961d8ce81 Author: xxx xxx@.com Date: Mon Mar 9 15:15:29 2020 +0800 update tomcat 7.0.90 commit 292dea9cedcf6f830eb166a3907f75eec6878a45 Author:xxx xxx@.com Date: Mon Mar 9 14:08:28 2020 +0800 update start-managaer.sh and start.sh gitlab回退到某次commit $ git reset --hard 292dea9cedcf6f830eb166a3907f75eec6878a45 强制重新提交 $ git push origin master --force Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Git/9_Git_Command.html":{"url":"Git/9_Git_Command.html","title":"9 Git Command","keywords":"","body":"Git 命令1. git clone:2 git remote3. git fetch4. git branch5. git pull 与git push6. git rev-parse7. git reset8. git config9. git diff10. git commit11 git rm12 git log13 git tagGit 命令 1. git clone: $ git clone https://github.com/jquery/jquery.git git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定 git clone -o jQuery https://github.com/jquery/jquery.git git clone -b 分支名 仓库地址 2 git remote git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show git remote add命令用于添加远程主机。 $ git remote add git remote rm命令用于删除远程主机。 $ git remote rm git remote rename命令用于远程主机的改名。 $ git remote rename 3. git fetch 一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 $ git fetch 比如，取回origin主机的master分支。 $ git fetch origin master 所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如origin主机的master，就要用origin/master读取。 4. git branch 分支（branch）的基本操作： git branch //查看本地所有分支 git branch -r //查看远程所有分支 git branch -a //查看本地和远程的所有分支 git branch //新建分支 git branch -d //删除本地分支 git branch -d -r //删除远程分支，删除后还需推送到服务器 git push origin: //删除后推送至服务器 git branch -m //重命名本地分支 //git中一些选项解释: -d --delete：删除 -D --delete --force的快捷键 -f --force：强制 -m --move：移动或重命名 -M --move --force的快捷键 -r --remote：远程 -a --all：所有 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 $ git checkout -b newBrach origin/master 创建分支命令： git branch (branchname) 切换分支命令: git checkout (branchname) 合并分支命令: git merge 列出分支基本命令： git branch git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下 删除分支命令： git branch -d (branchname) git branch * master newtest $ ls README test.txt test2.txt git merge newtest ls README test.txt 将 newtest 分支合并到主分支去，test2.txt 文件被删除 上面命令表示在当前分支上，合并origin/master。 5. git pull 与git push git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull : 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin $ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动\"追踪\"origin/master分支。 Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/ne使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push origin --tags 最后，git push不会推送标签（tag），除非使用--tags选项。 上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。 $ git push --force origin 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。 上面命令表示，将所有本地分支都推送到origin主机。 $ git push --all origin 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用--all选项。 $ git config --global push.default matching # 或者 $ git config --global push.default simple 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 $ git push -u origin master $ git push 如果当前分支只有一个追踪分支，那么主机名都可以省略。 上面命令表示，将当前分支推送到origin主机的对应分支。 $ git push originxt 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin 如果当前分支与多个主机存在追踪关系，则可以 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 上面命令表示删除origin主机的master分支。 $ git push origin :master # 等同于 $ git push origin --delete master 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 $ git push origin master 如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 注意，分支推送顺序的写法是:，所以git pull是:，而git push是:。 $ git push : git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git pull -p # 等同于下面的命令 $ git fetch --prune origin $ git fetch -p 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull --rebase : 如果合并需要采用rebase模式，可以使用--rebase选项。 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 $ git pull 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 上面命令表示，本地的当前分支自动与对应的origin主机\"追踪分支\"（remote-tracking branch）进行合并。 $ git pull origin 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 6. git rev-parse 准备工作 在工作区中建立目录 a/b/c ，进入该目录中。 cd /path/to/my/workspace/demo/ mkdir -p a/b/c cd /path/to/my/workspace/demo/a/b/c 显示版本库 .git 目录所在的位置。 $ git rev-parse --git-dir /path/to/my/workspace/demo/.git 显示工作区根目录。 $ git rev-parse --show-toplevel /path/to/my/workspace/demo 显示相对于工作区根目录的相对目录。 $ git rev-parse --show-prefix a/b/c 显示从当前目录（cd）后退（up）到工作区的根的深度。 $ git rev-parse --show-cdup ../../.. git rev-parse HEAD 获取当前最后一个的 commit hash $ [master] git rev-parse HEAD 51834cc95f15c81b1d8c6afc2625e50a81aadb23 面命令中的HEAD可以替换成branch name，如git rev-parse dev获取dev分支的最后一次提交 git rev-parse --abbrev-ref HEAD获取当前分支名 $ [master] git rev-parse --abbrev-ref HEAD master 上面命令都说是获取当前的XX，也就是说你运行命令时所在的 git 目录，如果在任何目录运行可以获取当前的XX，需要明确指出.git目录的位置以及git对应的工作目录。 $ git --git-dir='./maleskine/.git' rev-parse --abbrev-ref HEAD master 通过设置--git-dir选项，也可以正确的获取到maleskine项目当前的分支名。git还有一个选项--work-tree可以指定git的工作目录。 7. git reset git reset --hard logid(logid的前几位即可) --将版本库还原到历史的某个时刻的状态 git reset --hard HEAD^ --将版本库还原到上一次commit之前的状态 #有时候，进行了错误的提交，但是还没有push到远程分支，想要撤销本次提交，可以使用git reset –-soft/hard命令。 git reset –-soft：回退到某个版本，只回退了commit的信息，代码修改过的没变。如果还要提交，直接commit即可； git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉，即commit与修改过代码都撤销，变为原来的某个版本； 8. git config git config --global user.name 'username' --添加版本库的用户名到本地配置文件 git config --global user.emal 'emal' --添加版本库的用户邮箱到本地配置文件 9. git diff 执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别 尚未缓存的改动： git diff 查看已缓存的改动： git diff --cached 查看已缓存的与未缓存的所有改动： git diff HEAD 显示摘要而非整个 diff： git diff --stat 实例; git status -s git diff git add hello.php git status -s git diff --cached 10. git commit git commit -m 'test comment from w3cschool.cn' git add 提交缓存的流程太过繁琐，Git 也允许你用 -a 选项跳过这一步 git commit -am 'changes to hello file' git commit --signoff -m 'xxx' // 表示提交的信息中带有署名信息; git commit --amend 'xxx' // 表示对上一次提交的信息,进行修改提交; 11 git rm git rm 将文件从缓存区中移除 git rm hello.php git rm file 会将文件从缓存区和你的硬盘中（工作目录）删除。 如果要在工作目录中留着该文件 git rm --cached 12 git log git log 查看提交历史 git log --oneline --oneline 选项来查看历史记录的简洁的版本 git log --oneline --graph -graph 选项，查看历史中什么时候出现了分支、合并。 git log --reverse --oneline '--reverse'参数来逆向显示所有日志 git log --author=Linus --oneline -5 --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分 git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges 13 git tag git tag #查看所有标签 -a 选项意为\"创建一个带注解的标签\"。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解 git tag -a v1.0 git log --oneline --decorate --graph --decorate 时，我们可以看到我们的标签 追加标签 git tag -a v0.9 85fc7e7 git log --oneline --decorate --graph 指定标签信息命令： git tag -a -m \"w3cschool.cn标签\" PGP签名标签命令： git tag -s -m \"w3cschool.cn标签\" Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/":{"url":"Gitbook/","title":"Gitbook","keywords":"","body":"Gitbook1. 简介2. 官方 Gitbook3. 自定义 Gitbook4. 参考Gitbook 1. 简介 Gitbook 是一款优秀的开源文档管理工具, 具有丰富的开源插件，它的源码可以在 GitHub 上获取。 GitBook 是基于 Node.js 的开源命令行工具，用于输出漂亮的电子书。 GitBook 支持 Markdown 和 AsciiDoc 两种语法格式，能够输出 html，pdf，epub，mobi或者输出为静态网页多种格式。 GitBook 特性： Markdown 或 AsciiDoc 语法 多类型支持：网站(html)或电子书 (pdf, epub, mobi) 多语言 目录、大纲 封面 模板和变量 模板继承 插件 主题 2. 官方 Gitbook 在线编辑界面 预览效果 3. 自定义 Gitbook 预览效果 4. 参考 https://www.gitbook.com/ https://docs.gitbook.com/ http://www.zhaowenyu.com/gitbook-doc/ https://snowdreams1006.github.io/myGitbook/ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-03 16:23:54 "},"Gitbook/Plugins/":{"url":"Gitbook/Plugins/","title":"Plugins","keywords":"","body":"插件1. 默认插件2. 添加和移除插件3. 插件配置pluginsConfig4. 插件安装4.1 方法一4.2 方法二4.3 方法三5. 插件预览插件 1. 默认插件 Gitbook默认带有7个插件（功能性5个，搜索有两个，主题一个）： livereload 热加载插件 highlight 语法高亮插件 search 搜索插件 lunr 搜索插件后台服务 sharing 分享插件 fontsettings 字体设置插件 theme-default 主题 2. 添加和移除插件 在 book.json 中的 plugins 模块能够配置，能够使 Gitbook 的功能更丰富。 在 plugins 中添加对应的插件名称 \"plugins\": [ \"highlight\", \"-search\", \"back-to-top-button\", \"expandable-chapters-small\", \"insert-logo\" ] 其中\"-search\"中的 - 符号代表去除默认自带的插件 3. 插件配置pluginsConfig 部分插件在引入后需要进行详细的配置，可以在 pluginsConfig 中加配置说明。 \"pluginsConfig\": { \"insert-logo\": { \"url\": \"images/logo.png\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } 4. 插件安装 4.1 方法一 插件无需单独下载安装，只有在 book.json 中配置好对应的插件，执行 gitbook install, 缺少的插件就会自动下载安装 gitbook install . 4.2 方法二 自定义的插件也可以通过 npm 或者将解压后的包复制到 node_modules 目录中进行安装。 npm install gitbook-plugin-xxx 4.3 方法三 也可以从源码GitHub地址中下载，放到 node_modules 文件夹里（GitHub地址在进入插件地址右侧的GitHub链接）. 5. 插件预览 模块名称 功能描述 accordion 手风琴折叠模块 ace 代码 ACE 显示 advanced-emoji 显示 emoji 表情 alerts 告警级别信息提示 anchor-navigation-ex 悬浮目录和回到顶部 ancre-navigation 悬浮目录和回到顶部 auto-scroll-table 表格滚动条 back-to-top-button 当页面超过一屏幕时，会显示一个 回到顶部按钮 change_girls 可自动切换的背景 click-reveal 默认隐藏，点击可显示 code 代码添加行号&复制按钮 copy-code-button 代码复制按钮 custom-favicon 修改网页标题图标 favicon chapter-fold 导航目录默认折叠 Chart 绘制图形 donate 贡献 disqus 评论系统 emphasize 为文字加上底色 expandable-chapters 导航目录折叠扩展 expandable-chapters-small expandable-chapters-small edit-link 添加编辑按钮 favicon 显示网站图标 flexible-alerts flexible-alerts github 在右上角添加 github 图标 hide-element 可以隐藏不想看到的元素，比如导航栏中 Published by GitBook insert-logo 插入logo include-codeblock 包含或显示文件 include-csv 显示 CSV 文件内容 KaTex 数学公式支持 klipse klipse 嵌入类似IDE的功能 lightbox 单击查看图片 点击图片可显示，大小不变 lunr lunr local-video 视频 mermaid 流程图 Mermaid-gb3 流程图 Musicxml 乐谱渲染 page-copyright 页面页脚版权 page-toc-button 悬浮目录 page-top page-top.md page-treeview 生成页内目录 page-treeview-simple 生成页内目录精简版本 pageview-count 阅读量计数 popup 单击图片，在新页面查看大图 prism 语法高亮 PlantUML UML reward 赞赏组件 rss RSS 订阅 search 搜索 search-pro 高级搜索 search-plus search-plus sectionx 将页面分块显示 simple-page-toc 生成本页目录 sharing-plus 分享当前页面 sidebar-style 会替换掉 Published by GitBook splitter 侧边栏宽度可调节 sitemap-general 自动生成 sitemap 文件 summary 自动生成 SUMMARY.md tbfed-pagefooter 页面添加页脚 tags tags todo todo Terminal Terminal 终端 Version-select 文档多版本 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-30 12:40:11 "},"Gitbook/Plugins/1_Gitbook_Plugin_Summary.html":{"url":"Gitbook/Plugins/1_Gitbook_Plugin_Summary.html","title":"1 Gitbook Plugin Summary","keywords":"","body":"文章名字自动生成 SUMMARY.md文章名字自动生成 SUMMARY.md Gitbook 插件：自动生成 summary.md 文件内容，如果有很多md文件，这个插件可以帮助你生成初始版本。 $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install ` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (git-in-action) version: (1.0.0) description: This is a book about git、github、gitlab and gitbook. entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /root/github/git-in-action/package.json: { \"name\": \"git-in-action\", \"version\": \"1.0.0\", \"description\": \"This is a book about git、github、gitlab and gitbook.\", \"main\": \"index.js\", \"dependencies\": { \"gitbook-plugin-summary\": \"^1.1.0\", \"gitbook-plugin-theme-comscore\": \"^0.0.3\" }, \"devDependencies\": {}, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } Is this OK? (yes) yes 安装 gitbook-plugin-summary $ npm install gitbook-plugin-summary $ npm install -g gitbook-summary $ book sm $ cat SUMMARY.md # GitBook Handbook - Git * [1 Git Introduce](git/1_git_introduce.md) * [2 Git Command](git/2_git_command.md) * [3 Git Reset](git/3_git_reset.md) * [4 Git Ssh Login Without Secret](git/4_git_ssh_login_without_secret.md) - Github * [1 Github Introduce](github/1_github_introduce.md) * [2 Github Local Pull Github](github/2_github_local_pull_github.md) * [3 Github Action](github/3_github_action.md) * [4 Github Page](github/4_github_page.md) - Gitlab * [1 Gitlab Deploy](gitlab/1_gitlab_deploy.md) * [2 Gitlab Runner Deploy](gitlab/2_gitlab_runner_deploy.md) * [3 Gitlab Config](gitlab/3_gitlab_config.md) * [4 Gitlab Pipline](gitlab/4_gitlab_pipline.md) * [5 Gitlab Ci Config](gitlab/5_gitlab_ci_config.md) * [Information](information.md) [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 注意：如果没有命令book，执行: ln -s /usr/local/node-v10.24.0-linux-x64/bin/book /usr/local/bin/ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/Plugins/10_Gitbook_Plugin_Search.html":{"url":"Gitbook/Plugins/10_Gitbook_Plugin_Search.html","title":"10 Gitbook Plugin Search","keywords":"","body":"查询1. search 插件1.1 安装1.2 配置2. search-pro 高级搜索2.1 安装2.2 配置2.3 效果3. search-plus 插件3.1 安装3.2 配置3.3 效果查询 1. search 插件 search 插件：查找内容, 不支持中文 这个插件是 GitBook 的默认插件，它为你的书添加了一个交互式搜索栏。 该插件与后端无关。 1.1 安装 npm i gitbook-plugin-search 1.2 配置 { plugins: [\"-search\"] } 2. search-pro 高级搜索 search-pro插件支持中文搜索 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 在搜索结果中，关键字会高亮；自带的 search 插件，关键字不会高亮 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 在使用此插件之前，需要将默认的 search 和 lunr 插件去掉； 2.1 安装 npm i gitbook-plugin-search-pro 2.2 配置 book.json配置 { \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\" ] } 2.3 效果 见当前 book 左上角查找框 输入并搜索 3. search-plus 插件 search-plus 插件一个强大的 GitBook 搜索插件。 特征 搜索任何字符 跨元素搜索(用于搜索代码) 记住搜索url 插件地址：https://www.npmjs.com/package/gitbook-plugin-search-plus 3.1 安装 npm i gitbook-plugin-search-plus 3.2 配置 book.json配置 { plugins: [\"-lunr\", \"-search\", \"search-plus\"] } 3.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:20:37 "},"Gitbook/Plugins/11_Gitbook_Plugin_Commment.html":{"url":"Gitbook/Plugins/11_Gitbook_Plugin_Commment.html","title":"11 Gitbook Plugin Commment","keywords":"","body":"评论1. Disqus 插件1.1 安装1.2 配置1.3 效果评论 1. Disqus 插件 Disqus 是一个非常流行的为网站集成评论系统的工具，同样，gitbook 也可以集成 disqus 以便可以和读者交流。 首先，需要在 disqus 上注册一个账号，然后添加一个 website，这会获得一个关键字，然后在集成时配置这个关键字即可。 1.1 安装 npm i gitbook-plugin-disqus 1.2 配置 book.json配置： { \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"introducetogitbook\" } } } 注意：上面的 shortName 的值就是你在 disqus 上创建的 website 获得的唯一关键字。 1.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:28:14 "},"Gitbook/Plugins/12_Gitbook_Plugin_Copyright_Notice.html":{"url":"Gitbook/Plugins/12_Gitbook_Plugin_Copyright_Notice.html","title":"12 Gitbook Plugin Copyright Notice","keywords":"","body":"gitbook 插件: 版权声明1. tbfed-pagefooter 插件1.1 安装1.2 配置1.3 效果2. page-copyright 插件2.1 安装2.2 配置3. copyright 插件3.1 安装3.2 配置3.3 效果3.4 评价gitbook 插件: 版权声明 1. tbfed-pagefooter 插件 页面添加页脚 1.1 安装 npm i gitbook-plugin-tbfed-pagefooter 1.2 配置 { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy smoothies.com.cn 2022\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 1.3 效果 2. page-copyright 插件 page-copyright插件是页面页脚版权（内容更多） 2.1 安装 npm i gitbook-plugin-page-copyright 2.2 配置 { \"plugins\" : [\"page-copyright\"], \"pluginsConfig\" : { \"page-copyright\": { \"description\": \"modified at\", \"signature\": \"宗勋\", \"wisdom\": \"全栈工程师\", \"format\": \"YYYY-MM-dd hh:mm:ss\", \"copyright\": \"Copyright &#169; \", \"timeColor\": \"#666\", \"copyrightColor\": \"#666\", \"utcOffset\": \"8\", \"style\": \"normal\", \"noPowered\": false, } } } 运行以后有很多信息是原创作者的，这些配置都在你的插件安装目录 **\\node_modules\\gitbook-plugin-page-copyright 下的 index.js 中，自己可以修改。大部分信息都在 defaultOption 中。 那个二维码可以在文件中找到 QRcode 改成自己的，或者直接把所有的 defaultOption.isShowQRCode 改成false 3. copyright 插件 gitbook-plugin-copyright 是基于Gitbook实现的版权保护插件,用于复制内容时追加版权信息以及文章末尾添加版权小尾巴. 3.1 安装 npm i gitbook-plugin-copyright or gitbook install 3.2 配置 { \"plugins\": [\"copyright\"], \"pluginsConfig\": { \"copyright\": { \"site\": \"https://smoothies.com.cn/gitbook-demo/\", \"author\": \"ghostwritten\", \"website\": \"ghostwritten\", \"image\": \"https://pic4.zhimg.com/80/v2-94401c2c3fa20c1d5525cf6c16742909_xl.jpg\", \"copyProtect\": false } } } 3.3 效果 每一页末尾格式 3.4 评价 此设置致使文章界面增加无用、复杂，污染简约。 综合指数：综合指数：⭐️⭐️ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-20 00:05:16 "},"Gitbook/Plugins/13_Gitbook_Plugin_Background.html":{"url":"Gitbook/Plugins/13_Gitbook_Plugin_Background.html","title":"13 Gitbook Plugin Background","keywords":"","body":"gitbook 插件：背景设置1. change_girls 插件1.1 安装1.2 配置1.3 效果gitbook 插件：背景设置 1. change_girls 插件 change_girls插件功能是设置背景，并可自动切换的背景图片 1.1 安装 npm i gitbook-plugin-change_girls 1.2 配置 book.json配置： { \"plugins\":[\"change_girls\"], \"pluginsConfig\": { \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"https://www.bizhishe.com/d/file/2019-08-26/1566827846505876.jpg\", \"https://www.bizhishe.com/d/file/2019-07-24/1563977671157231.jpg\", \"https://www.bizhishe.com/d/file/2019-07-14/1563116649970786.jpg\" ] } } } 1.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:39:54 "},"Gitbook/Plugins/14_Gitbook_Plugin_Image_View.html":{"url":"Gitbook/Plugins/14_Gitbook_Plugin_Image_View.html","title":"14 Gitbook Plugin Image View","keywords":"","body":"gitbook 插件：图片查看1. lightbox 插件1.1 安装1.2 配置1.3 效果2. popup 插件2.1 安装2.2 配置2.3 效果gitbook 插件：图片查看 1. lightbox 插件 lightbox 插件：单击查看图片 点击图片可显示，大小不变 以弹窗形式查看图片，查看原图：lightbox 1.1 安装 npm i gitbook-plugin-lightbox 1.2 配置 { \"plugins\": [\"lightbox\"] } { \"pluginsConfig\": { \"lightbox\": { \"includeJQuery\": false \"sameUuid\": true \"options\": { \"resizeDuration\": 200, \"wrapAround\": true } } } } 1.3 效果 2. popup 插件 popup 插件：单击图片，在新页面查看大图。 2.1 安装 npm i gitbook-plugin-popup 2.2 配置 { \"plugins\": [ \"popup\" ] } 2.3 效果 略 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:40:57 "},"Gitbook/Plugins/15_Gitbook_Plugin_Icons_and_Logos.html":{"url":"Gitbook/Plugins/15_Gitbook_Plugin_Icons_and_Logos.html","title":"15 Gitbook Plugin Icons And Logos","keywords":"","body":"gitbook 插件：图标与LOGO1. custom-favicon 插件1.2 安装1.3 配置1.4 效果2. favicon 插件2.1 安装2.2 配置3. insert-logo 插件3.1 安装3.2 配置3.3 效果gitbook 插件：图标与LOGO 1. custom-favicon 插件 custom-favicon 插件: 修改网页标题图标 favicon 这个 pluginsConfig 和其他的不大一样。图标只能用 .ico 文件。 1.2 安装 npm i gitbook-plugin-custom-favicon 1.3 配置 { \"plugins\" : [\"custom-favicon\"], \"pluginsConfig\" : { \"favicon\": \"path/to/favicon.ico\" } } 把.ico 格式的图标放进项目中。这个路径可以使用相对路径，比如./images/a.ico 1.4 效果 2. favicon 插件 favicon 插件 ：修改网站图标 2.1 安装 npm i gitbook-plugin-favicon 2.2 配置 { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\", \"bookmark\": \"assets/images/favicon.ico\", \"appleTouch\": \"assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } 3. insert-logo 插件 insert-logo 插件 ：insert-logo 插入logo 3.1 安装 npm i gitbook-plugin-insert-logo 3.2 配置 { \"plugins\": [ \"insert-logo\" ] \"pluginsConfig\": { \"insert-logo\": { \"url\": \"http://www.fuming.site/dist/avator.jpg\", \"style\": \"background: none; max-height: 30px; min-height: 30px\" } } } 3.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:43:05 "},"Gitbook/Plugins/16_Gitbook_Plugin_Github.html":{"url":"Gitbook/Plugins/16_Gitbook_Plugin_Github.html","title":"16 Gitbook Plugin Github","keywords":"","body":"gitbook 插件：github1. github 插件1.1 安装1.2 配置1.3 效果gitbook 插件：github 1. github 插件 在右上角添加 github 图标。 这里是提供 github 的图标和URL 配置，URL可以根据自己需求配置。 1.1 安装 npm i gitbook-plugin-github 1.2 配置 { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/Ghostwritten\" } } } 1.3 效果 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 请阅览右上角。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-14 09:36:59 "},"Gitbook/Plugins/17_Gitbook_Plugin_Emoji.html":{"url":"Gitbook/Plugins/17_Gitbook_Plugin_Emoji.html","title":"17 Gitbook Plugin Emoji","keywords":"","body":"Emoji 表情包1. advanced-emoji 插件1.1 安装1.2 配置1.3 效果Emoji 表情包 1. advanced-emoji 插件 advanced-emoji 插件：支持显示 emoji 表情。 1.1 安装 npm i gitbook-plugin-advanced-emoji 1.2 配置 { \"plugins\" : [\"advanced-emoji\"] } 1.3 效果 People :bowtie: :smile: :laughing: :blush: :smiley: :relaxed: :smirk: :heart_eyes: :kissing_heart: :kissing_closed_eyes: :flushed: :relieved: :satisfied: :grin: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :grinning: :kissing: :kissing_smiling_eyes: :stuck_out_tongue: :sleeping: :worried: :frowning: :anguished: :open_mouth: :grimacing: :confused: :hushed: :expressionless: :unamused: :sweat_smile: :sweat: :disappointed_relieved: :weary: :pensive: :disappointed: :confounded: :fearful: :cold_sweat: :persevere: :cry: :sob: :joy: :astonished: :scream: :neckbeard: :tired_face: :angry: :rage: :triumph: :sleepy: :yum: :mask: :sunglasses: :dizzy_face: :imp: :smiling_imp: :neutral_face: :no_mouth: :innocent: :alien: :yellow_heart: :blue_heart: :purple_heart: :heart: :green_heart: :broken_heart: :heartbeat: :heartpulse: :two_hearts: :revolving_hearts: :cupid: :sparkling_heart: :sparkles: :star: :star2: :dizzy: :boom: :collision: :anger: :exclamation: :question: :grey_exclamation: :grey_question: :zzz: :dash: :sweat_drops: :notes: :musical_note: :fire: :hankey: :poop: :shit: :+1: :thumbsup: :-1: :thumbsdown: :ok_hand: :punch: :facepunch: :fist: :v: :wave: :hand: :raised_hand: :open_hands: :point_up: :point_down: :point_left: :point_right: :raised_hands: :pray: :point_up_2: :clap: :muscle: :metal: :fu: :walking: :runner: :running: :couple: :family: :two_men_holding_hands: :two_women_holding_hands: :dancer: :dancers: :ok_woman: :no_good: :information_desk_person: :raising_hand: :bride_with_veil: :person_with_pouting_face: :person_frowning: :bow: :couplekiss: :couple_with_heart: :massage: :haircut: :nail_care: :boy: :girl: :woman: :man: :baby: :older_woman: :older_man: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_turban: :construction_worker: :cop: :angel: :princess: :smiley_cat: :smile_cat: :heart_eyes_cat: :kissing_cat: :smirk_cat: :scream_cat: :crying_cat_face: :joy_cat: :pouting_cat: :japanese_ogre: :japanese_goblin: :see_no_evil: :hear_no_evil: :speak_no_evil: :guardsman: :skull: :feet: :lips: :kiss: :droplet: :ear: :eyes: :nose: :tongue: :love_letter: :bust_in_silhouette: :busts_in_silhouette: :speech_balloon: :thought_balloon: :feelsgood: :finnadie: :goberserk: :godmode: :hurtrealbad: :rage1: :rage2: :rage3: :rage4: :suspect: :trollface: Nature :sunny: :umbrella: :cloud: :snowflake: :snowman: :zap: :cyclone: :foggy: :ocean: :cat: :dog: :mouse: :hamster: :rabbit: :wolf: :frog: :tiger: :koala: :bear: :pig: :pig_nose: :cow: :boar: :monkey_face: :monkey: :horse: :racehorse: :camel: :sheep: :elephant: :panda_face: :snake: :bird: :baby_chick: :hatched_chick: :hatching_chick: :chicken: :penguin: :turtle: :bug: :honeybee: :ant: :beetle: :snail: :octopus: :tropical_fish: :fish: :whale: :whale2: :dolphin: :cow2: :ram: :rat: :water_buffalo: :tiger2: :rabbit2: :dragon: :goat: :rooster: :dog2: :pig2: :mouse2: :ox: :dragon_face: :blowfish: :crocodile: :dromedary_camel: :leopard: :cat2: :poodle: :paw_prints: :bouquet: :cherry_blossom: :tulip: :four_leaf_clover: :rose: :sunflower: :hibiscus: :maple_leaf: :leaves: :fallen_leaf: :herb: :mushroom: :cactus: :palm_tree: :evergreen_tree: :deciduous_tree: :chestnut: :seedling: :blossom: :ear_of_rice: :shell: :globe_with_meridians: :sun_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon: :waxing_crescent_moon: :first_quarter_moon: :waxing_gibbous_moon: :full_moon: :waning_gibbous_moon: :last_quarter_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :moon: :earth_africa: :earth_americas: :earth_asia: :volcano: :milky_way: :partly_sunny: :octocat: :squirrel: Objects :bamboo: :gift_heart: :dolls: :school_satchel: :mortar_board: :flags: :fireworks: :sparkler: :wind_chime: :rice_scene: :jack_o_lantern: :ghost: :santa: :christmas_tree: :gift: :bell: :no_bell: :tanabata_tree: :tada: :confetti_ball: :balloon: :crystal_ball: :cd: :dvd: :floppy_disk: :camera: :video_camera: :movie_camera: :computer: :tv: :iphone: :phone: :telephone: :telephone_receiver: :pager: :fax: :minidisc: :vhs: :sound: :speaker: :mute: :loudspeaker: :mega: :hourglass: :hourglass_flowing_sand: :alarm_clock: :watch: :radio: :satellite: :loop: :mag: :mag_right: :unlock: :lock: :lock_with_ink_pen: :closed_lock_with_key: :key: :bulb: :flashlight: :high_brightness: :low_brightness: :electric_plug: :battery: :calling: :email: :mailbox: :postbox: :bath: :bathtub: :shower: :toilet: :wrench: :nut_and_bolt: :hammer: :seat: :moneybag: :yen: :dollar: :pound: :euro: :credit_card: :money_with_wings: :e-mail: :inbox_tray: :outbox_tray: :envelope: :incoming_envelope: :postal_horn: :mailbox_closed: :mailbox_with_mail: :mailbox_with_no_mail: :door: :smoking: :bomb: :gun: :hocho: :pill: :syringe: :page_facing_up: :page_with_curl: :bookmark_tabs: :bar_chart: :chart_with_upwards_trend: :chart_with_downwards_trend: :scroll: :clipboard: :calendar: :date: :card_index: :file_folder: :open_file_folder: :scissors: :pushpin: :paperclip: :black_nib: :pencil2: :straight_ruler: :triangular_ruler: :closed_book: :green_book: :blue_book: :orange_book: :notebook: :notebook_with_decorative_cover: :ledger: :books: :bookmark: :name_badge: :microscope: :telescope: :newspaper: :football: :basketball: :soccer: :baseball: :tennis: :8ball: :rugby_football: :bowling: :golf: :mountain_bicyclist: :bicyclist: :horse_racing: :snowboarder: :swimmer: :surfer: :ski: :spades: :hearts: :clubs: :diamonds: :gem: :ring: :trophy: :musical_score: :musical_keyboard: :violin: :space_invader: :video_game: :black_joker: :flower_playing_cards: :game_die: :dart: :mahjong: :clapper: :memo: :pencil: :book: :art: :microphone: :headphones: :trumpet: :saxophone: :guitar: :shoe: :sandal: :high_heel: :lipstick: :boot: :shirt: :tshirt: :necktie: :womans_clothes: :dress: :running_shirt_with_sash: :jeans: :kimono: :bikini: :ribbon: :tophat: :crown: :womans_hat: :mans_shoe: :closed_umbrella: :briefcase: :handbag: :pouch: :purse: :eyeglasses: :fishing_pole_and_fish: :coffee: :tea: :sake: :baby_bottle: :beer: :beers: :cocktail: :tropical_drink: :wine_glass: :fork_and_knife: :pizza: :hamburger: :fries: :poultry_leg: :meat_on_bone: :spaghetti: :curry: :fried_shrimp: :bento: :sushi: :fish_cake: :rice_ball: :rice_cracker: :rice: :ramen: :stew: :oden: :dango: :egg: :bread: :doughnut: :custard: :icecream: :ice_cream: :shaved_ice: :birthday: :cake: :cookie: :chocolate_bar: :candy: :lollipop: :honey_pot: :apple: :green_apple: :tangerine: :lemon: :cherries: :grapes: :watermelon: :strawberry: :peach: :melon: :banana: :pear: :pineapple: :sweet_potato: :eggplant: :tomato: :corn: Places :house: :house_with_garden: :school: :office: :post_office: :hospital: :bank: :convenience_store: :love_hotel: :hotel: :wedding: :church: :department_store: :european_post_office: :city_sunrise: :city_sunset: :japanese_castle: :european_castle: :tent: :factory: :tokyo_tower: :japan: :mount_fuji: :sunrise_over_mountains: :sunrise: :stars: :statue_of_liberty: :bridge_at_night: :carousel_horse: :rainbow: :ferris_wheel: :fountain: :roller_coaster: :ship: :speedboat: :boat: :sailboat: :rowboat: :anchor: :rocket: :airplane: :helicopter: :steam_locomotive: :tram: :mountain_railway: :bike: :aerial_tramway: :suspension_railway: :mountain_cableway: :tractor: :blue_car: :oncoming_automobile: :car: :red_car: :taxi: :oncoming_taxi: :articulated_lorry: :bus: :oncoming_bus: :rotating_light: :police_car: :oncoming_police_car: :fire_engine: :ambulance: :minibus: :truck: :train: :station: :train2: :bullettrain_front: :bullettrain_side: :light_rail: :monorail: :railway_car: :trolleybus: :ticket: :fuelpump: :vertical_traffic_light: :traffic_light: :warning: :construction: :beginner: :atm: :slot_machine: :busstop: :barber: :hotsprings: :checkered_flag: :crossed_flags: :izakaya_lantern: :moyai: :circus_tent: :performing_arts: :round_pushpin: :triangular_flag_on_post: :jp: :kr: :cn: :us: :fr: :es: :it: :ru: :gb: :uk: :de: Symbols :one: :two: :three: :four: :five: :six: :seven: :eight: :nine: :keycap_ten: :1234: :zero: :hash: :symbols: :arrow_backward: :arrow_down: :arrow_forward: :arrow_left: :capital_abcd: :abcd: :abc: :arrow_lower_left: :arrow_lower_right: :arrow_right: :arrow_up: :arrow_upper_left: :arrow_upper_right: :arrow_double_down: :arrow_double_up: :arrow_down_small: :arrow_heading_down: :arrow_heading_up: :leftwards_arrow_with_hook: :arrow_right_hook: :left_right_arrow: :arrow_up_down: :arrow_up_small: :arrows_clockwise: :arrows_counterclockwise: :rewind: :fast_forward: :information_source: :ok: :twisted_rightwards_arrows: :repeat: :repeat_one: :new: :top: :up: :cool: :free: :ng: :cinema: :koko: :signal_strength: :u5272: :u5408: :u55b6: :u6307: :u6708: :u6709: :u6e80: :u7121: :u7533: :u7a7a: :u7981: :sa: :restroom: :mens: :womens: :baby_symbol: :no_smoking: :parking: :wheelchair: :metro: :baggage_claim: :accept: :wc: :potable_water: :put_litter_in_its_place: :secret: :congratulations: :m: :passport_control: :left_luggage: :customs: :ideograph_advantage: :cl: :sos: :id: :no_entry_sign: :underage: :no_mobile_phones: :do_not_litter: :non-potable_water: :no_bicycles: :no_pedestrians: :children_crossing: :no_entry: :eight_spoked_asterisk: :eight_pointed_black_star: :heart_decoration: :vs: :vibration_mode: :mobile_phone_off: :chart: :currency_exchange: :aries: :taurus: :gemini: :cancer: :leo: :virgo: :libra: :scorpius: :sagittarius: :capricorn: :aquarius: :pisces: :ophiuchus: :six_pointed_star: :negative_squared_cross_mark: :a: :b: :ab: :o2: :diamond_shape_with_a_dot_inside: :recycle: :end: :on: :soon: :clock1: :clock130: :clock10: :clock1030: :clock11: :clock1130: :clock12: :clock1230: :clock2: :clock230: :clock3: :clock330: :clock4: :clock430: :clock5: :clock530: :clock6: :clock630: :clock7: :clock730: :clock8: :clock830: :clock9: :clock930: :heavy_dollar_sign: :copyright: :registered: :tm: :x: :heavy_exclamation_mark: :bangbang: :interrobang: :o: :heavy_multiplication_x: :heavy_plus_sign: :heavy_minus_sign: :heavy_division_sign: :white_flower: :100: :heavy_check_mark: :ballot_box_with_check: :radio_button: :link: :curly_loop: :wavy_dash: :part_alternation_mark: :trident: :black_square: :white_square: :white_square: :white_check_mark: :black_square_button: :white_square_button: :black_circle: :white_circle: :red_circle: :large_blue_circle: :large_blue_diamond: :large_orange_diamond: :small_blue_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle_down: :shipit: Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:53:18 "},"Gitbook/Plugins/17_Gitbook_Plugin_Text_Hiding.html":{"url":"Gitbook/Plugins/17_Gitbook_Plugin_Text_Hiding.html","title":"17 Gitbook Plugin Text Hiding","keywords":"","body":"文本隐藏1. accordion 折叠模块1.1 安装1.2 配置1.3 效果2. click-reveal 插件2.1 安装2.2 配置2.3 效果3. hide-element 插件3.1 安装3.2 配置3.3 效果4. sectionx 插件4.1 安装4.2 配置4.3 添加按钮，控制部分可见性4.4 混合使用文本隐藏 1. accordion 折叠模块 折叠模块, 别名叫accordion。可以实现将内容隐藏起来，外部显示模块标题和显示箭头，点击箭头可显示里面的内容。 在文章中对主体内容进行细化说明较长，又不是文章核心逻辑时，可以隐藏细化说明部分，有需要时可以由读者决定是否阅读该部分细化说明。 1.1 安装 npm i gitbook-plugin-accordion 1.2 配置 { \"plugins\": [\"accordion\"] } 在文章中使用标记对内容进行折叠 1.3 效果 %accordion% 模块标题 %accordion% - 内容部分第1行 - 内容部分第2行 - 内容部分第3行 - 内容部分第4行 - 内容部分第5行 - 内容部分第6行 - 内容部分第7行 - 内容部分第8行 - 内容部分第9行 %/accordion% 2. click-reveal 插件 click-reveal 点击显示 默认隐藏，点击可显示。 2.1 安装 npm i gitbook-plugin-click-reveal 2.2 配置 { \"plugins\": [ \"click-reveal\" ] } 使用方式，markdown中 {% reveal %} 要被隐藏的内容 {% endreveal %} 默认显示的文字是 Click to show , 使用自定义显示文字 {% reveal text=\"点击显示\" %} 要被隐藏的内容 {% endreveal %} 支持html语法 点击显示 隐藏的文字 2.3 效果 3. hide-element 插件 hide-element 插件：可以隐藏不想看到的元素，比如导航栏中 Published by GitBook 3.1 安装 npm i gitbook-plugin-hide-element 3.2 配置 { \"plugins\": [ \"hide-element\" ], \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] } } } 3.3 效果 默认可以移除最左侧下方的提示信息： Published with GitBook 或 本书使用 Gitbook 发布 4. sectionx 插件 将页面分块显示 用于将页面分成多个部分，并添加按钮以允许读者控制每个部分的可见性。 下面有个更好的折叠模块功能accordion 4.1 安装 npm i gitbook-plugin-sectionx 4.2 配置 { \"plugins\": [ \"sectionx\" ] } 容分块： 在 .md 文件中定义一个部分（就是插入下面的字段）。 markdown中示例代码： 内容部分2； 这里只采用三个参数，其他参数如下所示： | 键 | 允许的值 | 说明 | |-----------------|--------------------------|-----------------------------| | !type | NOTE，TIP，WARNING和DANGER | 警告级别设置 | | style | 以下值之一: callout（默认）, flat | 警告样式，见图19的左右不同 | | label | 任何文字 | 警告块的标题位置，即Note这个字段位置（不支持中文） | | icon | 比如： fa fa-info-circle | 一个有效的Font Awesome图标，那块小符号 | | className | CSS类的名称 | 指定css文件，用于指定外观 | | labelVisibility | 以下值之一：visible（默认），hidden | 标签是否可见 | | iconVisibility | 以下值之一：visible（默认），hidden | 图标是否可见 | 4.3 添加按钮，控制部分可见性 通过在 GitBook 中添加内联HTML，以下代码可以添加一个按钮，以允许您查看或隐藏其他部分。 简单来说，就是在【使用1】的内容部分添加一个按钮： 标签说明： | 标签 | 说明 | |--------|----------------------------------------| | class | 该按钮必须属于类“section”。//这里就是用到 1部分的section | | target | 当按下时，将切换id为target的部分。 | | show | 隐藏目标部分时按钮上的文本。 | | hide | 目标部分可见时按钮上的文本。 | markdown中示例代码： 内容部分2 4.4 混合使用 将第2节的button块添加到第1节的内容部分 markdown中示例代码： 内容部分1； 内容部分2 效果图3： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:55:35 "},"Gitbook/Plugins/18_Gitbook_Plugin_TODO.html":{"url":"Gitbook/Plugins/18_Gitbook_Plugin_TODO.html","title":"18 Gitbook Plugin TODO","keywords":"","body":"Gitbook 插件：TODO1. todo 代办1.1 配置1.2 效果Gitbook 插件：TODO 1. todo 代办 插件地址：https://www.npmjs.com/package/gitbook-plugin-todo Warning 安装时失败 install plugin \"todo\" (*) from NPM with version 0.1.3 1.1 配置 { \"plugins\": [\"todo\"] } 1.2 效果 Markdown 语法 * [ ] write some articles * [x] drink a cup of tea 渲染效果 [ ] write some articles [x] drink a cup of tea Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:57:04 "},"Gitbook/Plugins/19_Gitbook_Plugin_Page_Editing.html":{"url":"Gitbook/Plugins/19_Gitbook_Plugin_Page_Editing.html","title":"19 Gitbook Plugin Page Editing","keywords":"","body":"Gitbook 插件：页面编辑1. edit-link 插件1.1 安装1.2 配置1.3 效果Gitbook 插件：页面编辑 1. edit-link 插件 edit-link 插件：添加编辑按钮 1.1 安装 npm i gitbook-plugin-edit-link 1.2 配置 { \"plugins\": [ \"edit-link\" ] } 1.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:59:55 "},"Gitbook/Plugins/2_Gitbook_Plugin_Title_Summary.html":{"url":"Gitbook/Plugins/2_Gitbook_Plugin_Title_Summary.html","title":"2 Gitbook Plugin Title Summary","keywords":"","body":"文件标题自动生成 SUMMARY.md1. 背景2. 需求3. 代码4. demo4.1 SUMMARY.md 添加文章4.2 SUMMARY.md 添加目录4.3 SUMMARY.md 添加子目录4.4 SUMMARY.md 覆盖4.5 SUMMARY.md 追加4.6 SUMMARY.md忽略4.7 SUMMARY.md替代文件标题自动生成 SUMMARY.md 1. 背景 我们了解 gitbook plugin summary 自动生成 summary.md 文件内容 这是book sm命令依赖markdown文章名字组成目录结构的样子。 $ npm install gitbook-plugin-summary $ npm install -g gitbook-summary $ book sm Finished, generated 'SUMMARY.md' successfully. $ cat SUMMARY.md # Git Handbook - Git * [2 Git Practice](Git/2_git_practice.md) - Gitbook * [1 Gitbook Start](Gitbook/1_gitbook_start.md) * [2 Gitbook Plugin Summary](Gitbook/2_gitbook-plugin-summary.md) * [3 Github Pages Gitbook](Gitbook/3_github_pages_gitbook.md) - Github * [1 Github Introduce](Github/1_github_introduce.md) * [2 Github Local Pull Github](Github/2_github_local_pull_github.md) * [3 Github Action](Github/3_github_action.md) * [4 Github Page](Github/4_github_page.md) - Gitlab * [1 Gitlab Start](Gitlab/1_gitlab_start.md) * [2 Gitlab Deploy](Gitlab/2_gitlab_deploy.md) * [3 Gitlab Config](Gitlab/3_gitlab_config.md) * [4 Gitlab Runner Deploy](Gitlab/4_gitlab_runner_deploy.md) * [5 Gitlab Runner Management](Gitlab/5_gitlab_runner_management.md) 但我的需求是可以依据文章标题来生成整个结构，因为如果你有一批大量的markdown文章一个一个手写改动、添加、删除都是一件非常麻烦的事。 我发现来自mofhu/GitBook-auto-summary的功能接近我的需求。 $ python3 gitbook-auto-summary.py -h usage: gitbook-auto-summary.py [-h] [-o] [-a] directory positional arguments: directory the directory of your GitBook root optional arguments: -h, --help show this help message and exit -o, --overwrite overwrite on SUMMARY.md -a, --append append on SUMMARY.md 功能： 可以通过-o覆盖已有的SUMMARY.md 新生成一个SUMMARY-GitBook-auto-summary.md 还可以通过-a实现追加内容。 2. 需求 但这离我渴望的需求还差一点点，那就是当文章内容存在标题，我更选择它来做链接名片，当不存在标题再去依赖文章名字（英文或中文）作为链接名片。并且在gitbook-auto-summary.py脚本当前目录我还可以让一些无关的目录作为例外。比如：node_modules 我把它实现了。 3. 代码 代码：@ghostwritten/GitBook-auto-summary # -*- coding: utf-8 -*- # Author Frank Hu & zong xun # GitBook auto summary # summary all .md files in a GitBook folder import argparse import os import re teshu_list = ['_book', 'node_modules', 'img'] def output_markdown(dire, base_dir, output_file, append, iter_depth=0): \"\"\"Main iterator for get information from every file/folder i: directory, base directory(to calulate relative path), output file name, iter depth. p: Judge is directory or is file, then process .md/.markdown files. o: write .md information (with identation) to output_file. \"\"\" top_list = os.listdir(dire) for i in top_list: if i in teshu_list: top_list.remove(i) for filename in sort_dir_file(top_list, base_dir): # add list and sort # print('Processing ', filename) # output log file_or_path = os.path.join(dire, filename) if os.path.isdir(file_or_path): #is dir if mdfile_in_dir(file_or_path): # if there is .md files in the folder, output folder name output_file.write(' ' * iter_depth + '- ' + filename + '\\n') print(' ' * iter_depth + '- ' + filename + '\\n') output_markdown(file_or_path, base_dir, output_file, append, iter_depth + 1) # iteration else: # is file if is_markdown_file(dire, base_dir,filename): # re to find target markdown files, $ for matching end of filename if (filename not in ['SUMMARY.md', 'SUMMARY-GitBook-auto-summary.md'] or iter_depth != 0): # escape SUMMARY.md at base directory output_file.write(' ' * iter_depth + '- [{}]({})\\n'.format(write_md_filename(dire, base_dir,filename, append), os.path.join(os.path.relpath(dire, base_dir), filename))) print(' ' * iter_depth + '- [{}]({})\\n'.format(write_md_filename(dire, base_dir,filename, append), os.path.join(os.path.relpath(dire, base_dir),filename))) # iter depth for indent, relpath and join to write link. def mdfile_in_dir(dire): \"\"\"Judge if there is .md file in the directory i: input directory o: return Ture if there is .md file; False if not. \"\"\" for root, dirs, files in os.walk(dire): for filename in files: if re.search('.md$|.markdown$', filename): return True return False def markdown_title_name(dire, base_dir,filename): path_filename = os.path.join(os.path.relpath(dire, base_dir), filename) with open(path_filename) as f: firstline = f.readline().rstrip() #if not firstline.isalnum(): if firstline == '' or firstline == '---': title = filename.split('.',1)[0] else: title = firstline.lower().strip() for i in range(0, len(title)): if not title[i].isalnum(): title = title[0:i] + ' ' + title[i+1:] while '--' in title: title = title.replace('--', ' ') title = title.strip(' ') return title def is_markdown_file(dire, base_dir,filename): \"\"\" Judge if the filename is a markdown filename i: filename o: filename without '.md' or '.markdown' \"\"\" if (filename not in ['SUMMARY.md','SUMMARY-GitBook-auto-summary.md']): match = re.search('.md$|.markdown$', filename) if not match: return False elif len(match.group()) is len('.md'): md_title = markdown_title_name(dire, base_dir,filename) return md_title elif len(match.group()) is len('.markdown'): md_title = markdown_title_name(dire, base_dir,filename) return md_title def sort_dir_file(listdir, dire): # sort dirs and files, first files a-z, then dirs a-z list_of_file = [] list_of_dir = [] for filename in listdir: if os.path.isdir(os.path.join(dire, filename)): list_of_dir.append(filename) else: list_of_file.append(filename) for dire in list_of_dir: list_of_file.append(dire) return list_of_file def write_md_filename(dire, base_dir,filename, append): \"\"\" write markdown filename i: filename and append p: if append: find former list name and return else: write filename \"\"\" if append: for line in former_summary_list: if re.search(filename, line): s = re.search('\\[.*\\]\\(',line) return s.group()[1:-2] else: return is_markdown_file(dire, base_dir,filename) else: return is_markdown_file(dire, base_dir,filename) def main(): parser = argparse.ArgumentParser() parser.add_argument('-o', '--overwrite', help='overwrite on SUMMARY.md', action=\"store_true\") parser.add_argument('-a', '--append', help='append on SUMMARY.md', action=\"store_true\") parser.add_argument('directory', help='the directory of your GitBook root') args = parser.parse_args() overwrite = args.overwrite append = args.append dir_input = args.directory # print information print('GitBook auto summary:', dir_input, end = ' ') if overwrite: print('--overwrite', end = ' ') if append and os.path.exists(os.path.join(dir_input, 'SUMMARY.md')): #append: read former SUMMARY.md print(os.listdir(dir_input)) print('--append', end = ' ') global former_summary_list with open(os.path.join(dir_input, 'SUMMARY.md')) as f: former_summary_list = f.readlines() f.close() print() # output to flie if (overwrite == False and os.path.exists(os.path.join(dir_input, 'SUMMARY.md'))): # overwrite logic filename = 'SUMMARY-GitBook-auto-summary.md' else: filename = 'SUMMARY.md' output = open(os.path.join(dir_input, filename), 'w') output.write('# Summary\\n\\n') output_markdown(dir_input, dir_input, output, append) print('GitBook auto summary finished:) ') return 0 if __name__ == '__main__': main() 我们验证它的效果。 4. demo 4.1 SUMMARY.md 添加文章 添加README.md $ ls gitbook-auto-summary.py README.md root@yourdomain:~/example/summary-demo# python3 gitbook-auto-summary.py . GitBook auto summary: . - [序言](./README.md) GitBook auto summary finished:) root@yourdomain:~/example/summary-demo# ls gitbook-auto-summary.py README.md SUMMARY.md root@yourdomain:~/example/summary-demo# cat SUMMARY.md # Summary - [序言](./README.md) 4.2 SUMMARY.md 添加目录 创建Git目录，并新增格式.md与.markdown格式文章。 $ ls Git/ 1_git_introduce.markdown 2_git_practice.md //查看是否有标题 $ head -n 1 Git/1_git_introduce.markdown # git 介绍 $ head -n 1 Git/2_git_practice.md # git 实践 $ python3 gitbook-auto-summary.py . GitBook auto summary: . - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [git 实践](Git/2_git_practice.md) GitBook auto summary finished:) root@yourdomain:~/example/summary-demo# ls Git gitbook-auto-summary.py README.md SUMMARY-GitBook-auto-summary.md SUMMARY.md 注意默认情况下（python3 gitbook-auto-summary.py .）当已存在 SUMMARY.md，脚本不会破坏已有SUMMARY.md。而是会生成新的文件：SUMMARY-GitBook-auto-summary.md $ cat SUMMARY-GitBook-auto-summary.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [git 实践](Git/2_git_practice.md) $ cat SUMMARY.md # Summary - [序言](./README.md) 4.3 SUMMARY.md 添加子目录 添加子目录并且添加一篇markdown文章。 ls Git/ 1_git_introduce.markdown 2_git_practice.md 3_git_remote_repo.md git_command root@yourdomain:~/example/summary-demo# ls Git/git_command/ 2_git_command.md root@yourdomain:~/example/summary-demo# head -n 1 Git/git_command/2_git_command.md # git 命令 执行如下： $ python3 gitbook-auto-summary.py -o . $ cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - git_command - [git 命令](Git/git_command/2_git_command.md) - [git 实践](Git/2_git_practice.md) 4.4 SUMMARY.md 覆盖 如果你只想覆盖SUMMARY.md 而已。可以python3 gitbook-auto-summary.py -o .实现。 $ python3 gitbook-auto-summary.py -o . GitBook auto summary: . --overwrite - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [git 实践](Git/2_git_practice.md) GitBook auto summary finished:) root@yourdomain:~/example/summary-demo# cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [git 实践](Git/2_git_practice.md) 有些情况，你可能认为覆盖比较危险，但又不想备份它，只想在原有的基础上追加内容。我们可以python3 gitbook-auto-summary.py -a .实现。 4.5 SUMMARY.md 追加 在Git目录新添了一篇文章。 $ ls Git/ 1_git_introduce.markdown 2_git_practice.md 3_git_remote_repo.md 并且我手动改一下 SUMMARY.md 内容做一个标记。把git 介绍改成git xxx # Gitbook-Handbook - [序言](./README.md) - Git - [git xxx](Git/1_git_introduce.markdown) - [git 实践](Git/2_git_practice.md) ls Git gitbook-auto-summary.py README.md SUMMARY.md 执行python3 gitbook-auto-summary.py -a .，SUMMARY.md修改的xxx并没有被覆盖掉。 $ python3 gitbook-auto-summary.py -a . $ cat SUMMARY-GitBook-auto-summary.md # Summary - [序言](./README.md) - Git - [git xxx](Git/1_git_introduce.markdown) - [github 管理远程仓库](Git/3_git_remote_repo.md) - [git 实践](Git/2_git_practice.md) 如果直接在SUMMARY.md追加。执行如下： $ python3 gitbook-auto-summary.py -a -o . $ cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git xxx](Git/1_git_introduce.markdown) - [github 管理远程仓库](Git/3_git_remote_repo.md) - [git 实践](Git/2_git_practice.md) 当去掉-a参数，覆盖重新生成。 $ python3 gitbook-auto-summary.py -o . $ cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [github 管理远程仓库](Git/3_git_remote_repo.md) - [git 实践](Git/2_git_practice.md) 4.6 SUMMARY.md忽略 我们创建一个目录img，也许你会用来存储图片。 $ mkdir img $ ls Git gitbook-auto-summary.py img README.md SUMMARY.md 修改代码第十行列表添加'img' ignore_list = ['_book', 'node_modules', 'img'] 执行如下： $ python3 gitbook-auto-summary.py -o . $ cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - [github 管理远程仓库](Git/3_git_remote_repo.md) - [git 实践](Git/2_git_practice.md) 大纲并没有收到影响。因为img目录已被当作例外。 4.7 SUMMARY.md替代 当markdown没有标题的时候，也就是说第一行内容为空，我们判断认定为标题不存在。“# xxxx”在其他行并不会被发现。这个时候我们会默认以文章名字作为链接名片。 我们把Git/git_commnad/2_git_command.md文章第一行的标题去掉或者下移一行。 $ head -n 2 Git/git_command/2_git_command.md # git 命令 执行如下： $ python3 gitbook-auto-summary.py -o . $ cat SUMMARY.md # Summary - [序言](./README.md) - Git - [git 介绍](Git/1_git_introduce.markdown) - git_command - [2_git_command](Git/git_command/2_git_command.md) - [github 管理远程仓库](Git/3_git_remote_repo.md) - [git 实践](Git/2_git_practice.md) 这也是最初book sm命令结果的样子。 参考链接： mofhu/GitBook-auto-summary Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/Plugins/20_Gitbook_Plugin_RSS.html":{"url":"Gitbook/Plugins/20_Gitbook_Plugin_RSS.html","title":"20 Gitbook Plugin RSS","keywords":"","body":"RSS1. RSS 插件1.1 安装1.2 配置1.3 参数RSS 1. RSS 插件 RSS 插件：添加 rss 订阅功能。 1.1 安装 npm i gitbook-plugin-rss 1.2 配置 { \"plugins\": [ \"rss\" ], \"pluginsConfig\": { \"rss\": { \"title\": \"GitBook 使用教程\", \"description\": \"记录 GitBook 的配置和一些插件的使用\", \"author\": \"Jikai Zhang\", \"feed_url\": \"http://gitbook.zhangjikai.com/rss\", \"site_url\": \"http://gitbook.zhangjikai.com/\", \"managingEditor\": \"me@zhangjikai.com\", \"webMaster\": \"me@zhangjikai.com\", \"categories\": [ \"gitbook\" ] } } } 效果见右上角。 1.3 参数 title (required string) — Title of your site or feed site_url (required url string) — Url to the site that the feed is for. feed_url (required url string) — Url to the rss feed. description (optional string) — A short description of the feed. generator (optional string) — Feed generator. image_url (optional url string) — Small image for feed readers to use. managingEditor (optional string) — Who manages content in this feed. webMaster (optional string) — Who manages feed availability and technical support. categories (optional array of strings) — One or more categories this feed belongs to. copyright (optional string) — Copyright information for this feed. language (optional string) — The language of the content of this feed. Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/Plugins/21_Gitbook_Plugin_Video.html":{"url":"Gitbook/Plugins/21_Gitbook_Plugin_Video.html","title":"21 Gitbook Plugin Video","keywords":"","body":"视频1. local-video 插件1.1 安装1.2 配置2. html3. video-player 插件3.1 安装3.2 配置4. youtube 插件4.1 安装4.2 配置4.3 语法4.4 效果4.5 评论视频 1. local-video 插件 local-video 插件添加链接描述：使用Video.js 播放本地视频 1.1 安装 npm i gitbook-plugin-local-video 1.2 配置 \"plugins\": [ \"local-video\" ] 使用示例：为了使视频可以自适应，我们指定视频的width为100%，并设置宽高比为16:9，如下面所示 {% raw %} To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video {% endraw %} 另外我们还要再配置下css，即在website.css中加入 .video-js { width:100%; height: 100%; } 2. html 3. video-player 插件 github:operatehappy@gitbook-plugin-videoplayer 功能尝试中 3.1 安装 gitbook install 3.2 配置 { \"plugins\": [\"video-player\"] } 首先，通过添加以下内容将所需的脚本和样式表添加到您的页面： {% videoplayerscripts %}{% endvideoplayerscripts %} 您现在可以使用此标签将 MP4 和 WebM 视频添加到您的图书中： {% videoplayer id=\"myvideo\" width=\"640\" height=\"480\" posterExt=\"png\" %}https://s3.amazonaws.com/gitbooks/myvideo{% endvideoplayer %} 放器将自动加载myvideo.mp4文件以显示 MP4 编码的视频。同样，它将默认myvideo.webm用于 WebM 编码的视频。 4. youtube 插件 youtube 插件是添加youtube视频。 4.1 安装 gitbook install or npm i gitbook-plugin-youtube 4.2 配置 { \"plugins\": [\"youtube\"] } 4.3 语法 {% youtube %} https://www.youtube.com/watch?v=-MdyiRH6OAc&t {% endyoutube %} 4.4 效果 4.5 评论 完美 综合指数：:star: Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-04 02:42:56 "},"Gitbook/Plugins/22_Gitbook_Plugin_SEO.html":{"url":"Gitbook/Plugins/22_Gitbook_Plugin_SEO.html","title":"22 Gitbook Plugin SEO","keywords":"","body":"SEO1. sitemap 插件1.1 安装1.2 配置2. sitemap-general 插件2.1 安装2.2 配置SEO 1. sitemap 插件 sitemap 插件：生成sitemap 1.1 安装 npm i gitbook-plugin-sitemap 1.2 配置 { \"plugins\": [\"sitemap\"], \"pluginsConfig\": { \"hostname\": { \"prefix\": \"https://www.example.com\" } } } 2. sitemap-general 插件 sitemap-general 插件：用来生成网站地图 sitemap (网站中页面的 URL 地址列表) 2.1 安装 npm i gitbook-plugin-sitemap-general 2.2 配置 { \"plugins\": [\"sitemap-general\"], \"pluginsConfig\": { \"sitemap-general\": { \"prefix\": \"http://gitbook.example.com\" } } } Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 07:03:53 "},"Gitbook/Plugins/23_Gitbook_Plugin_Statistics.html":{"url":"Gitbook/Plugins/23_Gitbook_Plugin_Statistics.html","title":"23 Gitbook Plugin Statistics","keywords":"","body":"gitbook 插件: 访问统计1. Google 统计1.1 安装1.2 配置2. Baidu 统计2.1 配置2.2 获取 Token2.3 效果3. pageview-count 插件3.1 安装3.2 配置3.3 效果gitbook 插件: 访问统计 1. Google 统计 1.1 安装 npm i gitbook-plugin-ga 1.2 配置 { \"plugins\": [\"ga\"] } book.json 中的插件配置设置 Google Analytics 跟踪 ID { \"plugins\": [\"ga\"], \"pluginsConfig\": { \"ga\": { \"token\": \"UA-XXXX-Y\" } } } 您可以通过传递其他配置选项来自定义跟踪器对象。您可以传入auto或none对象： { \"plugins\": [\"ga\"], \"pluginsConfig\": { \"ga\": { \"token\": \"UA-XXXX-Y\", \"configuration\": { \"cookieName\": \"new_cookie_name\", \"cookieDomain\": \"mynew.domain.com\" } } } } 2. Baidu 统计 2.1 配置 { \"plugins\": [\"3-ba\"], \"pluginsConfig\": { \"3-ba\": { \"token\": \"xxxxxxxx\" } } } 2.2 获取 Token 2.3 效果 3. pageview-count 插件 页面阅读量计数 3.1 安装 npm i gitbook-plugin-pageview-count 3.2 配置 book.json配置： { \"plugins\": [ \"pageview-count\" ] } 3.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:31:16 "},"Gitbook/Plugins/24_Gitbook_Plugin_navbor.html":{"url":"Gitbook/Plugins/24_Gitbook_Plugin_navbor.html","title":"24 Gitbook Plugin Navbor","keywords":"","body":"Gtibook 插件 顶部导航1. NavBar 插件2. 安装3. 配置4. 效果Gtibook 插件 顶部导航 1. NavBar 插件 2. 安装 从源码GitHub地址中下载，放到 node_modules 文件夹里（GitHub地址在进入插件地址右侧的GitHub链接）. $ cd node_modules $ git clone https://github.com/jchamath/gitbook-plugin-navbar.git 3. 配置 { \"plugins\": [\"navbar\"] } \"pluginsConfig\": { \"navbar\": { \"logo\": { \"link\": \"http://example.com/\", \"image\": \"http://example.com/resources/static/logo.png\", \"alt\": \"Example\" }, \"menu\": { \"items\": [{ \"text\": \"Home\", \"link\": \"http://example.com\" }, { \"text\": \"Page\", \"link\": \"http://example.com/page/\" }], \"style\": { \"color\": \"black\", \"hover\": \"#3579e2\" } }, \"style\": { \"backgroundColor\": \"white\", \"linkColor\": \"black\", \"linkHoverColor\": \"blue\" } }, } 4. 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-12 01:48:40 "},"Gitbook/Plugins/25_Gitbook_Plugin_Theme.html":{"url":"Gitbook/Plugins/25_Gitbook_Plugin_Theme.html","title":"25 Gitbook Plugin Theme","keywords":"","body":"Gitbook 插件 主题1. theme-default 插件1.1 安装1.2 配置1.3 效果2. theme-comscore 插件2.1 安装2.2 配置2.3 效果3. theme-api 插件3.1 安装3.2 配置3.3 语法3.4 效果3.5 布局Gitbook 插件 主题 1. theme-default 插件 theme-default 插件是 默认主题,大多数插件针对的都是默认主题。 默认情况下,左侧菜单不显示层级属性,如果将 showLevel 属性设置为 true 可以显示层级数字. 1.1 安装 npm i gitbook-plugin-theme-default 1.2 配置 \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } \"plugins\": [ \"theme-default\" ] 1.3 效果 2. theme-comscore 插件 theme-default 插件默认主题是黑白的,而theme-comscore插件 主题是彩色的,即标题和正文颜色有所区分. 2.1 安装 npm i gitbook-plugin-theme-comscore npm i -g gitbook-cli // maybe need sudo permission gitbook install 2.2 配置 { \"plugins\": [ \"theme-comscore\" ] } 2.3 效果 3. theme-api 插件 使用 GitBook 发布 API 文档的主题。 theme-api 主题与搜索插件（如默认插件或algolia）完美配合。 3.1 安装 npm i gitbook-plugin-theme-api 3.2 配置 { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } 3.3 语法 该主题允许使用模板块语法轻松定义具有不同语言示例的方法。 一个方法块可以包含任意数量的嵌套sample和common块。 这些嵌套块记录在下面。 {\\% method %} ## Install {#install} The first thing is to get the GitBook API client. {\\% sample lang=\"js\" %} \\```bash $ npm install gitbook-api \\ {\\% sample lang=\"go\" %} ```bash $ go get github.com/GitbookIO/go-gitbook-api ``` {\\% endmethod %} 在每个包含示例块的页面上，右上角method会自动添加一个切换器，以轻松选择要显示的语言。 可以在book.json文件中配置每种语言的名称，其lang属性对应于sample块lang参数： ```bash { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"languages\": [ { \"lang\": \"js\", // sample lang argument \"name\": \"JavaScript\", // corresponding name to be displayed \"default\": true // default language to show }, { \"lang\": \"go\", \"name\": \"Go\" } ] } } } 3.4 效果 3.5 布局 该主题提供了两种布局来显示您的示例：一列或两列（拆分）。当\"split\": true时为拆分布局。 { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"split\": true } } } 一栏布局 拆分布局 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-01 16:32:17 "},"Gitbook/Plugins/26_Gitbook_Plugin_Top_Navigation.html":{"url":"Gitbook/Plugins/26_Gitbook_Plugin_Top_Navigation.html","title":"26 Gitbook Plugin Top Navigation","keywords":"","body":"Gtibook 插件 顶部导航1. NavBar 插件1.1 安装1.2 配置1.3 效果1.4 评价2. theme-door 插件2.1 安装2.2 配置2.3 效果2.4 评价Gtibook 插件 顶部导航 1. NavBar 插件 1.1 安装 从源码GitHub地址中下载，放到 node_modules 文件夹里（GitHub地址在进入插件地址右侧的GitHub链接）. $ cd node_modules $ git clone https://github.com/jchamath/gitbook-plugin-navbar.git 1.2 配置 { \"plugins\": [\"navbar\"] } \"pluginsConfig\": { \"navbar\": { \"logo\": { \"link\": \"http://example.com/\", \"image\": \"http://example.com/resources/static/logo.png\", \"alt\": \"Example\" }, \"menu\": { \"items\": [{ \"text\": \"Home\", \"link\": \"http://example.com\" }, { \"text\": \"Page\", \"link\": \"http://example.com/page/\" }], \"style\": { \"color\": \"black\", \"hover\": \"#3579e2\" } }, \"style\": { \"backgroundColor\": \"white\", \"linkColor\": \"black\", \"linkHoverColor\": \"blue\" } }, } 1.3 效果 1.4 评价 简约，但嵌入页面有些呆板，与不能隐藏，没有下拉菜单功能。 综合指数：:star::star::star: 2. theme-door 插件 theme-door 插件含有Header导航，Sidebar导航以及MiniMap导航的gitbook主题。 2.1 安装 npm i gitbook-plugin-theme-door 2.2 配置 { \"plugins\": [ \"splitter\", \"hide-element\", \"code\", \"theme-door\", \"-lunr\", \"-search\", \"-sharing\", \"search-pro-fixed\" ], \"variables\": { \"doorTheme\": { \"nav\": [ { \"url\": \"xxxxx\", \"target\": \"_blank\", \"name\": \"论坛\" }, { \"url\": \"xxxxx\", \"target\": \"_blank\", \"name\": \"登录\" } ] } }, \"pluginsConfig\": { \"hide-element\": { \"elements\": [\".gitbook-link\"] }, \"doorTheme\": { \"search-placeholder\": \"请输入关键字搜索\", \"logo\": \"./_media/logo.svg\", \"favicon\": \"./_media/favicon.ico\" } } } 2.3 效果 2.4 评价 可在此基础二次自定义开发。目前默认主题不太友好。不能隐藏，没有下拉菜单功能。 综合指数：:star::star::star: Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-13 05:26:51 "},"Gitbook/Plugins/27_Gitbook_Plugin_Tags.html":{"url":"Gitbook/Plugins/27_Gitbook_Plugin_Tags.html","title":"27 Gitbook Plugin Tags","keywords":"","body":"gitbook 插件 标签1. tags 插件1.1 安装1.2 配置1.3 效果1.4 评价gitbook 插件 标签 1. tags 插件 tags 插件 给文章带上标签 1.1 安装 npm i gitbook-plugin-tags 1.2 配置 { \"plugins\": [ \"tags\" ], } 创建一个以tags.md根目录命名的文件并将其放在SUMMARY.md. 有效SUMMARY.md的是： # Summary * [Introduction](README.md) * [First Chapter](chapter1.md) * [Tags](tags.md) 您可以将文件保留为tags.md空或添加标题，例如 # Tags 在md文章页面中添加标签 $ head Linux-Command/Linux_Command_ab.md # linux Command ab 网站性能压力测试工具 tags: 测试 ..... 1.3 效果 1.4 评价 很完美 综合指数：⭐️⭐️⭐️⭐️⭐️ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-14 05:00:53 "},"Gitbook/Plugins/28_Gitbook_Plugin_pdf.html":{"url":"Gitbook/Plugins/28_Gitbook_Plugin_pdf.html","title":"28 Gitbook Plugin Pdf","keywords":"","body":"gitbook 插件 pdf1. pdf 插件1.1 安装1.2 导出 pdf2. pdf-multi-link 插件2.1 安装2.2 配置2.3 效果3. download-pdf-link 插件3.1 安装3.2 配置3.3 效果gitbook 插件 pdf 1. pdf 插件 1.1 安装 $ npm install gitbook-pdf -g 1.2 导出 pdf $ gitbook pdf ./my_repository 2. pdf-multi-link 插件 pdf-multi-link 插件在每个页面上添加一个链接以下载 PDF。 2.1 安装 npm i gitbook-plugin-pdf-multi-link 2.2 配置 { \"plugins\": [\"pdf-multi-link\"], \"pluginsConfig\": { \"download-pdf-link\": { \"base\": \"https://www.gitbook.com/book/poppy-project/poppy-docs/\", \"label\" }: { \"en\": \"Download PDF\", \"fr\": \"Télécharger le PDF\" } } } } { \"plugins\": [\"pdf-multi-link\"], \"pluginsConfig\": { \"download-pdf-link\": { \"base\": { \"en\":\"https://www.gitbook.com/book/poppy-project/poppy-docs/en.pdf\", \"fr\":\"https://www.gitbook.com/book/poppy-project/poppy-docs/fr.pdf\", }, \"label\" }: { \"en\": \"Download PDF\", \"fr\": \"Télécharger le PDF\" } } } } 2.3 效果 （略） 3. download-pdf-link 插件 download-pdf-link 插件在每个页面上添加一个链接以下载 PDF。 3.1 安装 npm i gitbook-plugin-download-pdf-link or gitbook install 3.2 配置 { \"plugins\": [\"download-pdf-link\"], \"pluginsConfig\": { \"download-pdf-link\": { \"base\": \"https://www.gitbook.com/book/poppy-project/poppy-docs/\", \"label\": { \"en\": \"Download PDF\", \"fr\": \"Télécharger le PDF\" } } } } 3.3 效果 （略） Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-19 07:31:54 "},"Gitbook/Plugins/29_Gitbook_Plugin_readmore.html":{"url":"Gitbook/Plugins/29_Gitbook_Plugin_readmore.html","title":"29 Gitbook Plugin Readmore","keywords":"","body":"gitbook 插件 阅读更多1. readmore 插件2. 安装3. 配置4. 效果gitbook 插件 阅读更多 1. readmore 插件 Gitbook 整合 OpenWrite 平台的 readmore 插件,实现博客的每一篇文章自动增加阅读更多效果,关注公众号后方可解锁全站文章,从而实现博客流量导流到微信公众号粉丝目的. 2. 安装 npm i gitbook-plugin-readmore or gitbook install 3. 配置 book.json { \"plugins\": [\"readmore\"], \"pluginsConfig\": { \"readmore\":{ \"blogId\": \"30114-1655653552581-278\", \"name\": \"爱死亡机器人\", \"qrcode\": \"https://raw.githubusercontent.com/Ghostwritten/gitbook-demo/master/assets/imgs/wechat.png\", \"keyword\": \"vip\" } } } 其中,配置参数含义如下: blogId : [必选]OpenWrite 后台申请的博客唯一标识,例如:30114-1655653552581-278 name : [必选]OpenWrite 后台申请的博客名称,例如：爱死亡机器人 qrcode : [必选]OpenWrite 后台申请的微信公众号二维码,例如：https://raw.githubusercontent.com/Ghostwritten/gitbook-demo/master/assets/imgs/wechat.png keyword : [必选]OpenWrite 后台申请的微信公众号后台回复关键字,例如:vip 4. 效果 （略） Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-19 17:02:16 "},"Gitbook/Plugins/3_Gitbook_Plugin_Side_Navigation.html":{"url":"Gitbook/Plugins/3_Gitbook_Plugin_Side_Navigation.html","title":"3 Gitbook Plugin Side Navigation","keywords":"","body":"侧边导航1. 简介1. chapter-fold 插件2. expandable-chapters 插件3. expandable-chapters-small 插件4. sidebar-style 插件5. splitter 插件侧边导航 1. 简介 Gitbook 提供的书籍默认都会在左侧提供书籍目录索引导航的功能。 对于侧边导航功能、UI、布局、效果等等有一些开源的插件可供选择，插件的核心功能与差异： chapter-fold 插件: 默认的侧边目录是全部展开的，该插件可以让文章按照层级目录折叠起来，同时只能展开一个目录。 expandable-chapters 插件: 默认的侧边目录是全部展开的，该插件可以让文章按照层级目录折叠起来，展开后不会自动折叠。 expandable-chapters-small 插件: 默认的侧边目录是全部展开的，该插件可以让文章按照层级目录折叠起来，展开后不会自动折叠，箭头相比 expandable-chapters 会细一些。 sidebar-style 插件: 会替换掉 Published by GitBook，并在左侧最上面显示标题。 splitter 插件:提供侧边栏宽度可调节功能。 本站点使用： expandable-chapters-small 插件 sidebar-style 插件 splitter 插件 1. chapter-fold 插件 安装 npm i gitbook-plugin-expandable-chapters-small 默认的侧边目录是全部展开的，该插件可以使左侧导航目录默认折叠。 在点击折叠目录时，只会展开一个目录，新的目录展开时其他目录会折叠。 { \"plugins\": [\"chapter-fold\"] } 效果图： 2. expandable-chapters 插件 安装 npm i gitbook-plugin-expandable-chapters 默认的侧边目录是全部展开的，该插件可以使左侧导航目录默认折叠。 可以支持点击展开后的目录一直保持展开的状态，这点和 chapter-fold 不同。 和 expandable-chapters-small 效果相同，唯一不同的是这个插件的箭头粗一些。 { \"plugins\": [ \"expandable-chapters\" ] } 效果图： 3. expandable-chapters-small 插件 安装 npm i gitbook-plugin-expandable-chapters-small 默认的侧边目录是全部展开的，该插件可以使左侧导航目录默认折叠。 可以支持点击展开后的目录一直保持展开的状态，这点和 chapter-fold 不同。 和 expandable-chapters 插件 效果相同，差异是折叠展开箭头图标小一些。 { \"plugins\": [ \"expandable-chapters-small\" ] } 效果图： 4. sidebar-style 插件 安装 npm i gitbook-plugin-sidebar-style 在左侧最上方添加标题。 在左侧导航最下方替换掉 Published by GitBook 提示信息 { \"plugins\": [\"sidebar-style\"], \"pluginsConfig\": { \"sidebar-style\": { \"title\": \"《Git Demo》\", \"author\": \"zongxun\" } } } 效果图： 5. splitter 插件 安装 npm i gitbook-plugin-splitter 侧边栏宽度可调节 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 05:11:57 "},"Gitbook/Plugins/30_Gitbook_Plugin_music.html":{"url":"Gitbook/Plugins/30_Gitbook_Plugin_music.html","title":"30 Gitbook Plugin Music","keywords":"","body":"gitbook 插件：音乐1. gitbook-plugin-zymplayer 插件1.1 配置1.2 安装1.3 效果1.4 评论gitbook 插件：音乐 @[toc] 1. gitbook-plugin-zymplayer 插件 gitbook-plugin-zymplayer 插件 可以播放音乐。 1.1 配置 \"plugins\": [ \"zymplayer\" ] \"pluginsConfig\": { \"zymplayer\": { \"element\": \"body\", \"width\": \"350px\", \"mode\": \"random\", \"show\": \"all\", \"list\": { \"path\": \"assets/music/musicList.json\", \"height\": 180, \"expand\": true }, \"position\": { \"pos\": \"fixed\", \"right\": \"0px\", \"bottom\": \"0px\" } } } 音乐列表存放musicList.json、音乐mp3在目录song、音乐图片在目录img $ ls assets/music/ img musicList.json song $ ls assets/music/img/ Angel_Lover-Prendre_sa_main.png dylanf_卡农.jpg Peter_Jeremias-Dusk.jpg 张宇桦_大自然的空气_钢琴曲.jpg 陈光荣_Tanning_In_Your_Sunray.jpg Denean-Vow_to_Virtue.jpg Jocelyn_Pook_Russian_Red-Loving_Strangers.jpg Vexento_Anesthesia.jpg 群星_森林之歌.jpg $ ls assets/music/song/ Angel_Lover-Prendre_sa_main.mp3 dylanf_卡农.mp3 Peter_Jeremias-Dusk.mp3 张宇桦_大自然的空气_钢琴曲.mp3 陈光荣_Tanning_In_Your_Sunray.mp3 Denean-Vow_to_Virtue.mp3 Jocelyn_Pook_Russian_Red-Loving_Strangers.mp3 Vexento_Anesthesia.mp3 群星_森林之歌.mp3 musicList.json内容如下： cat assets/music/musicList.json [ { \"name\": \"Tanning In Your Sunray\", \"artist\": \"陈光荣\", \"url\": \"assets/music/song/陈光荣_Tanning_In_Your_Sunray.mp3\", \"cover_art_url\": \"assets/music/img/陈光荣_Tanning_In_Your_Sunray.jpg\", \"duration\": \"03:38\" }, { \"name\": \"Prendre sa main\", \"artist\": \"Angel Lover\", \"url\": \"assets/music/song/Angel_Lover-Prendre_sa_main.mp3\", \"cover_art_url\": \"assets/music/img/Angel_Lover-Prendre_sa_main.jpg\", \"duration\": \"03:31\" }, { \"name\": \"Vow to Virtue\", \"artist\": \"Denean\", \"url\": \"assets/music/song/Denean-Vow_to_Virtue.mp3\", \"cover_art_url\": \"assets/music/img/Denean-Vow_to_Virtue.jpg\", \"duration\": \"03:43\" }, { \"name\": \"Loving Strangers\", \"artist\": \"Jocelyn Pook Russian Red\", \"url\": \"assets/music/song/Jocelyn_Pook_Russian_Red-Loving_Strangers.mp3\", \"cover_art_url\": \"assets/music/img/Jocelyn_Pook_Russian_Red-Loving_Strangers.jpg\", \"duration\": \"03:43\" }, { \"name\": \"Dusk\", \"artist\": \"Peter Jeremias\", \"url\": \"assets/music/song/Peter_Jeremias-Dusk.mp3\", \"cover_art_url\": \"assets/music/img/Peter_Jeremias-Dusk.jpg\", \"duration\": \"02:05\" }, { \"name\": \"Anesthesia\", \"artist\": \"Vexento\", \"url\": \"assets/music/song/Vexento_Anesthesia.mp3\", \"cover_art_url\": \"assets/music/img/Vexento_Anesthesia.jpg\", \"duration\": \"03:41\" }, { \"name\": \"森林之歌\", \"artist\": \"群星\", \"url\": \"assets/music/song/群星_森林之歌.mp3\", \"cover_art_url\": \"assets/music/img/群星_森林之歌.jpg\", \"duration\": \"02:04\" }, { \"name\": \"张宇桦_大自然的空气_钢琴曲\", \"artist\": \"张宇桦_大自然的空气_钢琴曲\", \"url\": \"assets/music/song/张宇桦_大自然的空气_钢琴曲.mp3\", \"cover_art_url\": \"assets/music/img/张宇桦_大自然的空气_钢琴曲.jpg\", \"duration\": \"02:22\" }, { \"name\": \"卡农\", \"artist\": \"dylanf\", \"url\": \"assets/music/song/dylanf_卡农.mp3\", \"cover_art_url\": \"assets/music/img/dylanf_卡农.jpg\", \"duration\": \"05:00\" } ] 1.2 安装 gitbook install 1.3 效果 1.4 评论 插件效果很好，但存在bug，影响logo暂时，子目录下拉显示等等。 综合指数：:star::star::star: Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-08-10 08:37:34 "},"Gitbook/Plugins/4_Gitbook_Plugin_Directory_Navigation.html":{"url":"Gitbook/Plugins/4_Gitbook_Plugin_Directory_Navigation.html","title":"4 Gitbook Plugin Directory Navigation","keywords":"","body":"文章目录导航1. anchor-navigation-ex插件2. ancre-navigation 插件3. back-to-top-button 插件4. page-toc-button 插件文章目录导航 1. anchor-navigation-ex插件 anchor-navigation-ex插件功能是：悬浮目录和回到顶部 安装： npm i gitbook-plugin-anchor-navigation-ex 添加 Toc 到侧边悬浮导航以及回到顶部按钮。需要注意以下两点： 本插件只会提取 h[1-3] 标签作为悬浮导航 只有按照以下顺序嵌套才会被提取 必须要以 h1 开始，直接写 h2 不会被提取 anchor-navigation-ex 和 会互相叠加影响，应选择其中一种即可 在 books.json 添加配置 { plugins: [\"anchor-navigation-ex\"], pluginsConfig: [ \"anchor-navigation-ex\": { \"tocLevel1Icon\": \"fa fa-hand-o-right\", \"tocLevel2Icon\": \"fa fa-hand-o-right\", \"tocLevel3Icon\": \"fa fa-hand-o-right\", \"multipleH1\": false, \"multipleH2\": false, \"multipleH3\": false, \"multipleH4\": false, \"showLevelIcon\": false, \"showLevel\": false }, } 在文章中使用1/2/3级标题 # h1 ## h2 ### h3 右上角目录图标预览效果 2. ancre-navigation 插件 ancre-navigation 插件功能是：右上角悬浮导航和回到顶部按钮 安装 npm i gitbook-plugin-anchor-navigation-ex 方法： { plugins: [\"ancre-navigation\"] } 效果图： 3. back-to-top-button 插件 back-to-top-button 插件功能：当页面超过一屏幕时，会显示一个 回到顶部按钮 安装 npm i gitbook-plugin-anchor-navigation-ex 地址： gitbook-plugin-back-to-top-button book.json配置： { \"plugins\": [ \"back-to-top-button\" ] } 效果图 4. page-toc-button 插件 page-toc-button 插件功能：悬浮目录 安装 npm i gitbook-plugin-anchor-navigation-ex 方法 { \"plugins\" : [ \"page-toc-button\" ] } 可选配置项： \"pluginsConfig\": { \"page-toc-button\": { \"maxTocDepth\": 2, \"minTocSize\": 2 } } maxTocDept 标题的最大深度（2 = h1 + h2 + h3）。不支持值> 2。 默认2 minTocSize 显示toc按钮的最小toc条目数。 默认 2 效果图： 页面toc按钮: 页面toc菜单: Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/Plugins/5_Gitbook_Plugin_Article_TOC.html":{"url":"Gitbook/Plugins/5_Gitbook_Plugin_Article_TOC.html","title":"5 Gitbook Plugin Article TOC","keywords":"","body":"TOC 目录1. page-treeview 插件2. page-treeview-simple 插件3. simple-page-toc 插件4. page-toc 插件TOC 目录 1. page-treeview 插件 page-treeview 插件是生成页内目录 不需要插入标签，能支持到6级目录，安装可用 安装 npm i gitbook-plugin-simple-page-toc book.json配置： { \"plugins\": [\"page-treeview\"] } 非必要配置： \"pluginsConfig\": { \"page-treeview\": { \"copyright\": \"Copyright &#169; aleen42\", \"minHeaderCount\": \"2\", \"minHeaderDeep\": \"2\" } } 这个插件生成目录以后，下面有一行关于版权的文字。如果想去掉的话，找到插件目录下的index.js文件：***/node_modules/gitbook-plugin-page-treeview/lib/index.js 找到如下这段代码 2. page-treeview-simple 插件 和 page-treeview 功能相同，在其基础之上修改了以下内容： 去除 copyRight 的提示内容与占用的空白高 取消章节的折叠效果，默认展开显示完整章节 效果图 3. simple-page-toc 插件 simple-page-toc 插件生成本页目录 需要在文章中插入标签，支持1-3级目录 页面顶端生成。另外 GitBook 在处理重复的标题时有些问题，所以尽量不适用重复的标题。 安装 npm i gitbook-plugin-simple-page-toc book.json配置： { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 参数 说明 \"maxDepth\": 3 使用深度最多为maxdepth的标题。 \"skipFirstH1\": true 排除文件中的第一个h1级标题。 使用方法: 在需要生成目录的地方用下面的标签括起来，全文都生成的话就在首尾添加 效果图： 4. page-toc 插件 page-toc 插件在你的 Gitbook 的每个页面上添加了一个目录 (TOC)。您可以设置目录是否默认显示在所有页面上，您可以启用或禁用个别页面上的目录以覆盖默认值。 安装 npm i gitbook-plugin-page-toc-af book.json配置: { \"plugins\": [ \"page-toc\" ], \"pluginsConfig\": { \"page-toc\": { \"selector\": \".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4\", \"position\": \"before-first\", \"showByDefault\": true } } } Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 05:15:18 "},"Gitbook/Plugins/6_Gitbook_Plugin_Tips_and_Emphasis.html":{"url":"Gitbook/Plugins/6_Gitbook_Plugin_Tips_and_Emphasis.html","title":"6 Gitbook Plugin Tips And Emphasis","keywords":"","body":"提示与强调1. alerts 插件1.1 安装1.2 配置1.3 效果2. flexible-alerts 插件2.1 安装2.2 配置2.3 扩展配置2.4 效果12.5 自定义一个COMMENT类型2.6. 效果23. emphasize 插件3.1 安装3.2 配置3.3 效果提示与强调 1. alerts 插件 alerts 插件功能是告警级别信息提示。这个GitBook插件将块引用转换为漂亮的警报。 1.1 安装 npm i gitbook-plugin-alerts 1.2 配置 book.json配置： { \"plugins\": [\"alerts\"] } 1.3 效果 info 信息样式 > **[info] For info** > > Use this for infomation messages. [info] For info Use this for infomation messages. warning 警告造型 > **[warning] For warning** > > Use this for warning messages. [warning] For warning Use this for warning messages. danger 危险造型 > **[danger] For danger** > > Use this for danger messages. [danger] For danger Use this for danger messages. success 成功造型 > **[success] For success** > > Use this for success messages. [success] For success Use this for success messages. 2. flexible-alerts 插件 flexible-alerts 插件将块引用转换为漂亮的警报，相比 alerts 具有更多的拓展功能。 可以在全局和警报特定级别配置外观，因此输出确实符合您的需求（如下图）。此外，您还可以提供自己的警报类型（比如最后的comment）。 Github地址：https://github.com/zanfab/gitbook-plugin-flexible-alerts#readme 2.1 安装 npm i gitbook-plugin-flexible-alerts 2.2 配置 book.json配置： { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"note\": { \"label\": \"Hinweis\" }, \"tip\": { \"label\": \"Tipp\" }, \"warning\": { \"label\": \"Warnung\" }, \"danger\": { \"label\": \"Achtung\" } } } } 2.3 扩展配置 语法： > [!type|style:xx|label:xx|icon:xx|className:xx|labelVisibility:xx|iconVisibility:xx] > 内容部分 字段介绍，如果不设置的表示选择默认，除了!type都不是必需 | 键 | 允许的值 | 说明 | |-----------------|--------------------------|-----------------------------| | !type | NOTE，TIP，WARNING和DANGER | 警告级别设置 | | style | 以下值之一: callout（默认）, flat | 警告样式，见图19的左右不同 | | label | 任何文字 | 警告块的标题位置，即Note这个字段位置（不支持中文） | | icon | 比如： fa fa-info-circle | 一个有效的Font Awesome图标，那块小符号 | | className | CSS类的名称 | 指定css文件，用于指定外观 | | labelVisibility | 以下值之一：visible（默认），hidden | 标签是否可见 | | iconVisibility | 以下值之一：visible（默认），hidden | 图标是否可见 | 效果对比： > [!NOTE] > 这是一个简单的Note类型的使用，所有的属性都是默认值。 > [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] > \"!type\":`NOTE`、\"style\":`flat`、\"lable\":`自定义标签`、图标不可见 默认的 NOTE [!NOTE] 这是一个简单的Note类型的使用，所有的属性都是默认值。 添加设置的 NOTE [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] \"!type\":NOTE、\"style\":flat、\"lable\":自定义标签、图标不可见 2.4 效果1 2.5 自定义一个COMMENT类型 在book.json中添加以下内容。然后执行gitbook install，或者使用NPM安装（单独安装推荐NPM）npm install gitbook-plugin-flexible-alerts，也可以从源码GitHub地址中下载，放到node_modules文件夹里（GitHub地址在进入插件地址右侧的GitHub链接）： { \"plugins\": [ \"flexible-alerts\" ], \"pluginsConfig\": { \"flexible-alerts\": { \"style\": \"callout\", \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } } 自定义COMMENT > [!COMMENT] > An alert of type 'comment' using style 'callout' with default settings. [!COMMENT] An alert of type 'comment' using style 'callout' with default settings. 2.6. 效果2 Info styling Info styling > [!NOTE] > An alert of type 'note' using global style 'callout'. Info styling [!NOTE] An alert of type 'note' using global style 'callout'. Info flat Info flat > [!NOTE|style:flat] > An alert of type 'note' using alert specific style 'flat' which overrides global style 'callout'. Info flat [!NOTE|style:flat] An alert of type 'note' using alert specific style 'flat' which overrides global style 'callout'. Tip style Tip style > [!TIP|style:flat|label:My own heading|iconVisibility:hidden] > An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. > In addition, this alert uses an own heading and hides specific icon. Tip style [!TIP|style:flat|label:My own heading|iconVisibility:hidden] An alert of type 'tip' using alert specific style 'flat' which overrides global style 'callout'. In addition, this alert uses an own heading and hides specific icon. Warning styling Warning styling > **[!WARNING] For warning** > Use this for warning messages. Warning styling [!WARNING] For warning Use this for warning messages. danger styling danger styling > **[!DANGER] For danger** > Use this for danger messages. danger styling [!DANGER] For danger Use this for danger messages. 3. emphasize 插件 emphasize 插件功能是为文字加上底色 3.1 安装 npm i gitbook-plugin-simple-page-toc 3.2 配置 { \"plugins\": [ \"emphasize\" ] } 3.3 效果 在 markdown / asciidoc 内容中，使用以下内容突出显示一些文本： - This text is {% em %}highlighted !{% endem %} - This text is {% em %}highlighted with **markdown**!{% endem %} - This text is {% em type=\"green\" %}highlighted in green!{% endem %} - This text is {% em type=\"red\" %}highlighted in red!{% endem %} - This text is {% em color=\"#ff0000\" %}highlighted with a custom color!{% endem %} 效果: This text is highlighted ! This text is highlighted with markdown! This text is highlighted in green! This text is highlighted in red! This text is highlighted with a custom color! Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-10 02:28:38 "},"Gitbook/Plugins/7_Gitbook_Plugin_Code_Block.html":{"url":"Gitbook/Plugins/7_Gitbook_Plugin_Code_Block.html","title":"7 Gitbook Plugin Code Block","keywords":"","body":"代码块1. code 插件1.1 安装1.2 配置1.3 效果2. copy-code-button 插件2.1 安装2.2 配置2.3 效果3. klipse 插件3.1 安装3.2 方法3.3 效果4. Prism 插件4.1 安装4.2 配置4.3 效果5. prism-themes 插件5.1 安装5.2 配置5.3 效果6. ACE 插件6.1 安装6.2 配置6.3 效果7. Terminal 插件7.1 安装7.2 配置7.3 效果8. codesnippet 插件8.1 安装8.2 配置8.3 语法8.4 效果8.5 评价代码块 1. code 插件 code 代码添加行号&复制按钮 1.1 安装 npm i gitbook-plugin-code-pro 1.2 配置 book.json配置： { \"plugins\" : [ \"code\" ] } 如果想去掉复制按钮，可配置 \"pluginsConfig\": { \"code\": { \"copyButtons\": false } } 1.3 效果 注意左侧行数编号和右上角的复制按钮 2. copy-code-button 插件 copy-code-button 插件功能是代码复制按钮 2.1 安装 npm i gitbook-plugin-copy-code-button 2.2 配置 { \"plugins\": [\"copy-code-button\"] } 2.3 效果 3. klipse 插件 klipse 插件是嵌入类似IDE的功能 3.1 安装 npm i gitbook-plugin-klipse 3.2 方法 { \"plugins\": [\"klipse\"] } 用法，在 markdown 中 print [x + 1 for x in range(10)] 3.3 效果 klipse 目前支持下面的语言： javascript: evaluation is done with the javascript function eval and pretty printing of the result is done with pretty-format clojure[script]: evaluation is done with Self-Hosted Clojurescript ruby: evaluation is done with Opal C++: evaluation is done with JSCPP python: evaluation is done with Skulpt scheme: evaluation is done with BiwasScheme PHP: evaluation is done with Uniter BrainFuck JSX EcmaScript2017 Google Charts: See Interactive Business Report with Google Charts. 4. Prism 插件 Prism 插件使用 Prism.js 为语法添加高亮显示，需要将 highlight 插件去掉。该插件自带的主题样式较少，可以再安装 prism-themes 插件，里面多提供了几种样式，具体的样式可以参考 这里，在设置样式时要注意设置 css 文件名，而不是样式名。 4.1 安装 npm i gitbook-plugin-prism 4.2 配置 { \"plugins\": [ \"prism\", \"-highlight\" ] } 4.2.1 css 覆盖默认样式。所有css文件必须位于同一个文件夹中。 \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-solarizedlight.css\" ] } } 4.2.2 lang 通过别名现有前缀来支持非标准语法前缀。 \"pluginsConfig\": { \"prism\": { \"lang\": { \"flow\": \"typescript\" } } } 4.2.3 ignore 由于其他插件使用代码块的概念来表示其他功能，你可以忽略某些语言。 \"pluginsConfig\": { \"prism\": { \"ignore\": [ \"mermaid\", \"eval-js\" ] } } 4.3 效果 4.3.1 Prism Themes https://github.com/PrismJS/prism $ ls node_modules/prismjs/themes/ prism-coy.css prism.css prism-dark.min.css prism-funky.min.css prism-okaidia.css prism-solarizedlight.css prism-tomorrow.css prism-twilight.css prism-coy.min.css prism-dark.css prism-funky.css prism.min.css prism-okaidia.min.css prism-solarizedlight.min.css prism-tomorrow.min.css prism-twilight.min.css Okaidia prismjs/themes/prism-okaidia.css Solarized Light prismjs/themes/prism-solarizedlight.css Tomorrow prismjs/themes/prism-tomorrow.css Dark prismjs/themes/prism-dark.css Coy prismjs/themes/prism-coy.css 4.3.2 Atelierbram Themes https://github.com/atelierbram/syntax-highlighting Base16 Ocean Dark syntax-highlighting/assets/css/prism/prism-base16-ocean.dark.css Google Light syntax-highlighting/assets/css/prism/prism-base16-google.light.css Xonokai syntax-highlighting/assets/css/prism/prism-xonokai.css 5. prism-themes 插件 当使用gitbook-plugin-prism时，prism-themes 插件提供了额外的主题。 5.1 安装 npm i gitbook-plugin-prism-themes 或者 gitbook install 5.2 配置 { \"plugins\": [\"-highlight\", \"prism\", \"prism-themes\"] } \"pluginsConfig\": { \"prism\": { \"css\": [ \"prism-themes/themes/prism-duotone-dark.css\" ] } } 5.3 效果 Available themes 6. ACE 插件 ACE插件是使 GitBook 支持ace 。 6.1 安装 npm i gitbook-plugin-ace 6.2 配置 默认情况下，line-height 为 1，会使代码显得比较挤，而作者好像没提供修改行高的选项，如果需要修改行高，可以到 node_modules -> github-plugin-ace -> assets -> ace.js 中加入下面两行代码 (30 行左右的位置)： editor.container.style.lineHeight = 1.25; editor.renderer.updateFontSize(); 不过上面的做法有个问题就是，每次使用 gitbook install 安装新的插件之后，代码又会重置为原来的样子。另外可以在 website.css 中加入下面的 css 代码来指定 ace 字体的大小 .aceCode { font-size: 14px !important; } 使用插件： \"plugins\": [ \"ace\" ] 使用示例: // This is a hello world program for C. #include int main(){ printf(\"Hello World!\"); return 1; } 6.3 效果 略 7. Terminal 插件 Terminal 插件功能是模拟终端显示，主要用于显示命令以及多行输出，不过写起来有些麻烦。 7.1 安装 npm i gitbook-plugin-terminal 7.2 配置 terminal 支持下面 5 种样式，如果需要更换样式，在 pluginsConfig 里配置即可。 black: Just that good old black terminal everybody loves. classic: Looking for green color font over a black background? This is for you. flat: Oh, flat colors. I love flat colors. Everything looks modern with them. ubuntu: Admit it or not, but Ubuntu have a good looking terminal. white: Make your terminal to blend in with your GitBook. book.json配置： { \"plugins\": [ \"terminal\" ], \"pluginsConfig\": { \"terminal\": { \"copyButtons\": true, \"fade\": false, \"style\": \"flat\" } } } 现在支持 6 种标签： command: Command \"executed\" in the terminal. delimiter: Sequence of characters between the prompt and the command. error: Error message. path: Directory path shown in the prompt. prompt: Prompt of the user. warning: Warning message. 标签的使用格式如下所示： **[ 内容] 为了使标签正常工作，需要在代码块的第一行加入 **[termial] 标记，下面是一个完整的示例： **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] 7.3 效果 略 8. codesnippet 插件 codesnippet 插件可以轻松导入代码文件或在 GitBook 的代码块中使用变量。 8.1 安装 npm i gitbook-plugin-codesnippet 8.2 配置 { \"plugins\": [\"codesnippet\"] } 8.3 语法 添加代码内容: This is a code snippet: {% codesnippet \"./myfile.js\" %}{% endcodesnippet %} 指定语言类型: This is a code snippet, display as HTML: {% codesnippet \"./myfile.ejs\", language=\"html\" %}{% endcodesnippet %} 指定行范围： This is a code snippet, display as HTML: {% codesnippet \"./myfile.ejs\", lines=\"2:5\" %}{% endcodesnippet %} 带有模板语法的代码块 This is a code snippet, display as HTML: {% codesnippet %} curl {{ book.hostname|d(\"http://localhost\") }}/myapi {% endcodesnippet %} 8.4 效果 （略） 8.5 评价 很方便，但用处不太大，略感繁琐。 综合指数：⭐️⭐️⭐️ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-16 15:30:42 "},"Gitbook/Plugins/8_Gitbook_Plugin_Sharing.html":{"url":"Gitbook/Plugins/8_Gitbook_Plugin_Sharing.html","title":"8 Gitbook Plugin Sharing","keywords":"","body":"分享1. sharing-plus 插件1.1 安装1.2 配置1.3 效果分享 1. sharing-plus 插件 sharing-plus 插件：分享当前页面，比默认的 sharing 插件多了一些分享方式。 1.1 安装 npm i gitbook-plugin-sharing-plus 1.2 配置 { \"plugins\": [\"-sharing\", \"sharing-plus\"], \"pluginsConfig\": { \"sharing\": { \"douban\": false, \"facebook\": false, \"google\": true, \"pocket\": false, \"qq\": false, \"qzone\": true, \"twitter\": false, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"whatsapp\" ] } } } 其中： 为true的代表直接显示在页面顶端，为false的不显示，不写默认为false \"all\"中代表点击分享符号显示出来的 支持的网站如下： \"douban\", \"facebook\", \"google\", \"hatenaBookmark\", \"instapaper\", \"linkedin\",\"twitter\", \"weibo\", \"messenger\",\"qq\", \"qzone\",\"viber\",\"vk\",\"weibo\", \"pocket\", \"stumbleupon\",\"whatsapp\" 1.3 效果 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:03:18 "},"Gitbook/Plugins/9_Gitbook_Plugin_Appreciate.html":{"url":"Gitbook/Plugins/9_Gitbook_Plugin_Appreciate.html","title":"9 Gitbook Plugin Appreciate","keywords":"","body":"gitbook 插件 赞赏1. donate 打赏插件1.1 安装1.2 配置1.3 效果gitbook 插件 赞赏 @[toc] 1. donate 打赏插件 如果喜欢，请打赏 1.1 安装 npm i gitbook-plugin-donate 1.2 配置 book.json配置： { plugins: [ ”donate“ ], \"pluginsConfig\": [' \"donate\": { \"wechat\": \"https://github.com/Ghostwritten/gitbook-demo/blob/gh-pages/img/aplipay.png?raw=true\", \"alipay\": \"https://github.com/Ghostwritten/gitbook-demo/blob/gh-pages/img/wechat.png?raw=true\", \"title\": \"鼓励一下\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, ] } 1.3 效果 [!TIP|style:flat|label:My own heading|iconVisibility:hidden] 请点击\"打赏\"，查看效果。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 06:10:15 "},"Gitbook/1_Gitbook_Get_Started.html":{"url":"Gitbook/1_Gitbook_Get_Started.html","title":"1 Gitbook Get Started","keywords":"","body":"Gitbook 快速入门1. 介绍2. 条件3. gitbook 安装4. gitbook 创建5. SUMMARY.md6. README.md7. book.json7.1 侧栏添加链接7.2 添加一个插件Gitbook 快速入门 1. 介绍 Gitbook 是一款优秀的 基于 Node.js 的开源文档管理工具，具有丰富的开源插件。 GitBook 支持 Markdown 和 AsciiDoc 两种语法格式，能够输出 html，pdf，epub，mobi 等多种格式。 2. 条件 nodejs 安装 node一定要安装10.X版本，否则报如下错误： CLI version: 2.3.2 Installing GitBook 3.2.3 /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:193:5) 系统：ubuntu：18.04 3. gitbook 安装 $ npm install gitbook-cli -g /usr/local/node/bin/gitbook -> /usr/local/node/lib/node_modules/gitbook-cli/bin/gitbook.js + gitbook-cli@2.3.2 added 578 packages from 672 contributors in 191.662s #找到gitbook命令位置 $ ls /usr/local/node-v10.24.0-linux-x64/bin/ gitbook node node_modules/ npm npx package-lock.json #添加软连接 $ ln -s /usr/local/node-v10.24.0-linux-x64/bin/gitbook /usr/local/bin/ $ ln -s /usr/local/node-v10.24.0-linux-x64/bin/book /usr/local/bin/ $ gitbook -V CLI version: 2.3.2 Installing GitBook 3.2.3 gitbook@3.2.3 ../../../../tmp/tmp-117466TKiRhUq3ov0O/node_modules/gitbook ├── escape-html@1.0.3 ├── escape-string-regexp@1.0.5 ├── destroy@1.0.4 ├── ignore@3.1.2 ├── bash-color@0.0.4 ├── gitbook-plugin-livereload@0.0.1 ├── cp@0.2.0 ├── nunjucks-do@1.0.0 ├── graceful-fs@4.1.4 ├── github-slugid@1.0.1 ├── direction@0.1.5 ├── q@1.4.1 ├── spawn-cmd@0.0.2 ├── gitbook-plugin-fontsettings@2.0.0 ├── open@0.0.5 ├── is@3.3.0 ├── object-path@0.9.2 ├── extend@3.0.2 ├── json-schema-defaults@0.1.1 ├── gitbook-plugin-search@2.2.1 ├── jsonschema@1.1.0 ├── crc@3.4.0 ├── urijs@1.18.0 ├── semver@5.1.0 ├── immutable@3.8.2 ├── front-matter@2.3.0 ├── npmi@2.0.1 (semver@4.3.6) ├── resolve@1.1.7 ├── gitbook-plugin-theme-default@1.0.7 ├── moment@2.13.0 ├── npm@3.9.2 ├── dom-serializer@0.1.0 (domelementtype@1.1.3, entities@1.1.2) ├── tmp@0.0.28 (os-tmpdir@1.0.2) ├── error@7.0.2 (xtend@4.0.2, string-template@0.2.1) ├── omit-keys@0.1.0 (isobject@0.2.0, array-difference@0.0.1) ├── mkdirp@0.5.1 (minimist@0.0.8) ├── js-yaml@3.14.1 (esprima@4.0.1, argparse@1.0.10) ├── gitbook-plugin-lunr@1.2.0 (html-entities@1.2.0, lunr@0.5.12) ├── gitbook-plugin-highlight@2.0.2 (highlight.js@9.2.0) ├── gitbook-plugin-sharing@1.0.2 (lodash@3.10.1) ├── i18n-t@1.0.1 (lodash@4.17.21) ├── gitbook-markdown@1.3.2 (kramed-text-renderer@0.2.1, gitbook-html@1.3.3, kramed@0.5.6, lodash@4.17.21) ├── gitbook-asciidoc@1.2.2 (gitbook-html@1.3.3, asciidoctor.js@1.5.5-1, lodash@4.17.21) ├── send@0.13.2 (fresh@0.3.0, etag@1.7.0, statuses@1.2.1, range-parser@1.0.3, ms@0.7.1, depd@1.1.2, mime@1.3.4, debug@2.2.0, http-errors@1.3.1, on-finished@2.3.0) ├── fresh-require@1.0.3 (is-require@0.0.1, shallow-copy@0.0.1, astw@1.3.0, acorn@0.9.0, sleuth@0.1.1, escodegen@1.14.3, through2@0.6.5) ├── rmdir@1.2.0 (node.flow@1.2.3) ├── request@2.72.0 (tunnel-agent@0.4.3, aws-sign2@0.6.0, forever-agent@0.6.1, oauth-sign@0.8.2, is-typedarray@1.0.0, caseless@0.11.0, stringstream@0.0.6, aws4@1.11.0, isstream@0.1.2, json-stringify-safe@5.0.1, tough-cookie@2.2.2, node-uuid@1.4.8, qs@6.1.2, hawk@3.1.3, combined-stream@1.0.8, mime-types@2.1.34, http-signature@1.1.1, form-data@1.0.1, bl@1.1.2, har-validator@2.0.6) ├── read-installed@4.0.3 (debuglog@1.0.1, util-extend@1.0.3, slide@1.1.6, readdir-scoped-modules@1.1.0, read-package-json@2.1.2) ├── cpr@1.1.1 (rimraf@2.4.5) ├── tiny-lr@0.2.1 (parseurl@1.3.3, livereload-js@2.4.0, qs@5.1.0, debug@2.2.0, faye-websocket@0.10.0, body-parser@1.14.2) ├── cheerio@0.20.0 (entities@1.1.2, lodash@4.17.21, css-select@1.2.0, htmlparser2@3.8.3, jsdom@7.2.2) ├── juice@2.0.0 (deep-extend@0.4.2, slick@1.12.2, batch@0.5.3, cssom@0.3.1, cross-spawn-async@2.2.5, commander@2.9.0, web-resource-inliner@2.0.0) ├── chokidar@1.5.0 (async-each@1.0.3, path-is-absolute@1.0.1, inherits@2.0.4, glob-parent@2.0.0, is-glob@2.0.1, is-binary-path@1.0.1, anymatch@1.3.2, readdirp@2.2.1) └── nunjucks@2.5.2 (asap@2.0.6, yargs@3.32.0, chokidar@1.7.0) GitBook version: 3.2.3 4. gitbook 创建 $ mkdir gitbook-demo $ cd gitbook-demo #使用 gitbook init 初始化书籍目录 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished $ ls README.md SUMMARY.md #使用 gitbook build 编译书籍 $ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.4s ! $ ls _book README.md SUMMARY.md $ ls _book/ gitbook index.html search_index.json $ ls _book/gitbook/ fonts gitbook.js gitbook-plugin-fontsettings gitbook-plugin-highlight gitbook-plugin-lunr gitbook-plugin-search gitbook-plugin-sharing images style.css theme.js #使用 gitbook serve 编译并预览书籍 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 效果 图中侧栏Introduction的内容正是README.md的内容，SUMMARY.md 是编写界面侧栏的目录结构。 $ cat README.md # Introduction $ cat SUMMARY.md # Summary * [Introduction](README.md) 5. SUMMARY.md GitBook 使用文件 SUMMARY.md 来定义书本的章节和子章节的结构。文件 SUMMARY.md 被用来生成书本内容的预览表。 SUMMARY.md 的格式是一个简单的链接列表，链接的名字是章节的名字，链接的指向是章节文件的路径。子章节被简单的定义为一个内嵌于父章节的列表。以 # 开头的行为注释被忽略。 GitBook使用一个SUMMARY.md文件来定义文档的菜单。 虽说在官方文档中，它是可选的，但是它相当重要，控制了左边菜单栏的显示内容。它通过 Markdown 中的列表语法来表示文件的父子关系。紧凑型的。 创建一个目录，并编写一个markdown格式的文档 $ mkdir git $ mv git_training.md git $ ls _book book.json book.json_bak git kubernetes node_modules README.md SUMMARY.md $ ls git/ 1_git_introduce.md 2_git_command.md 编写SUMMARY.md # Summary ## 前言 * [Introduction](README.md) ## git * [git 介绍](git/1_git_introduce.md) * [git 命令](git/2_git_training.md) 启动 $ gitbook serve 效果： 当 md 文件数量非常多时，我们可以利用 插件 summary 自动生成菜单 summary 文件的介绍。 6. README.md 书本的首页内容默认是从文件 README.md 中提取的。 README.md是 gitbook 最基础的文件之一，它一般用来描述这本书最基本的信息。 它呈现给读者这本书最初的样子，如果内容不够简洁明了，很可能就没有看下去的欲望了。 可以通过 gitbook init 自动创建该文件。 如果这个文件名没有出现在 SUMMARY.md (目录索引文件) 中，那么它会被添加为章节的第一个条目。 如何替代README.md 一些项目更愿意将 README.md 文件作为项目的介绍而不是书的介绍。 大部分代码托管平台将 README.md 自动显示到项目首页，如果你不喜欢这样。 从GitBook >2.0.0 起，就可以在 book.json 中定义某个文件作为README。 删除掉SUMMARY.md文档关于README.md的引用 编写information.md $ cat information.md --- 这是一本关于介绍git、github、gitlab、gitbook的书籍。 比起官方的理解，它更接近体验训练。 book.json添加structure参数 book.json { \"structure\" : { \"readme\" : \"information.md\" } } 启动 $ gitbook serve 效果：默认的首页 7. book.json 7.1 侧栏添加链接 $ ls _book book.json kubernetes README.md SUMMARY.md $ vim book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"Blog\": \"https://blog.csdn.net/xixihahalelehehe?spm=1000.2115.3001.5343\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": \"GitBook Handbook\", \"variables\": {} } $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 效果，只看到了一个Blog链接。 7.2 添加一个插件 编写book.json添加新theme-comscore颜色插件 $ cat book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"Blog\": \"https://blog.csdn.net/xixihahalelehehe?spm=1000.2115.3001.5343\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [ \"theme-comscore\" ], \"title\": \"GitBook Handbook\", \"variables\": {} } 安装插件 gitbook install info: installing 1 plugins using npm@3.9.2 info: info: installing plugin \"theme-comscore\" info: install plugin \"theme-comscore\" (*) from NPM with version 0.0.3 /root/github/gitbook-demo └── gitbook-plugin-theme-comscore@0.0.3 info: >> plugin \"theme-comscore\" installed with success 执行 $ gitbook serve 添加主题插件前： 添加主题插件后： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/2_Gitbook_Install.html":{"url":"Gitbook/2_Gitbook_Install.html","title":"2 Gitbook Install","keywords":"","body":"Gitbook 安装1. node & npm 安装2. gitbook 安装3. gitbook 创建Gitbook 安装 1. node & npm 安装 cd /usr/local wget https://nodejs.org/dist/v17.4.0/node-v17.4.0-linux-x64.tar.gz tar -zxvf node-v17.4.0-linux-x64.tar.gz ln -s /usr/local/node-v17.4.0-linux-x64/bin/node /usr/local/bin/ ln -s /usr/local/node-v17.4.0-linux-x64/bin/npm /usr/local/bin/ node -v v17.4.0 npm -v 8.3.1 nodejs 安装 node一定要安装10.X版本，否则报如下错误： CLI version: 2.3.2 Installing GitBook 3.2.3 /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/node/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:193:5) 系统：ubuntu：18.04 2. gitbook 安装 $ npm install gitbook-cli -g /usr/local/node/bin/gitbook -> /usr/local/node/lib/node_modules/gitbook-cli/bin/gitbook.js + gitbook-cli@2.3.2 added 578 packages from 672 contributors in 191.662s #找到gitbook命令位置 $ ls /usr/local/node-v10.24.0-linux-x64/bin/ gitbook node node_modules/ npm npx package-lock.json #添加软连接 $ ln -s /usr/local/node-v10.24.0-linux-x64/bin/gitbook /usr/local/bin/ $npm install -g gitbook-summary #安装book命令 $ ln -s /usr/local/node-v10.24.0-linux-x64/bin/book /usr/local/bin/ $ gitbook -V CLI version: 2.3.2 Installing GitBook 3.2.3 gitbook@3.2.3 ../../../../tmp/tmp-117466TKiRhUq3ov0O/node_modules/gitbook ├── escape-html@1.0.3 ├── escape-string-regexp@1.0.5 ├── destroy@1.0.4 ├── ignore@3.1.2 ├── bash-color@0.0.4 ├── gitbook-plugin-livereload@0.0.1 ├── cp@0.2.0 ├── nunjucks-do@1.0.0 ├── graceful-fs@4.1.4 ├── github-slugid@1.0.1 ├── direction@0.1.5 ├── q@1.4.1 ├── spawn-cmd@0.0.2 ├── gitbook-plugin-fontsettings@2.0.0 ├── open@0.0.5 ├── is@3.3.0 ├── object-path@0.9.2 ├── extend@3.0.2 ├── json-schema-defaults@0.1.1 ├── gitbook-plugin-search@2.2.1 ├── jsonschema@1.1.0 ├── crc@3.4.0 ├── urijs@1.18.0 ├── semver@5.1.0 ├── immutable@3.8.2 ├── front-matter@2.3.0 ├── npmi@2.0.1 (semver@4.3.6) ├── resolve@1.1.7 ├── gitbook-plugin-theme-default@1.0.7 ├── moment@2.13.0 ├── npm@3.9.2 ├── dom-serializer@0.1.0 (domelementtype@1.1.3, entities@1.1.2) ├── tmp@0.0.28 (os-tmpdir@1.0.2) ├── error@7.0.2 (xtend@4.0.2, string-template@0.2.1) ├── omit-keys@0.1.0 (isobject@0.2.0, array-difference@0.0.1) ├── mkdirp@0.5.1 (minimist@0.0.8) ├── js-yaml@3.14.1 (esprima@4.0.1, argparse@1.0.10) ├── gitbook-plugin-lunr@1.2.0 (html-entities@1.2.0, lunr@0.5.12) ├── gitbook-plugin-highlight@2.0.2 (highlight.js@9.2.0) ├── gitbook-plugin-sharing@1.0.2 (lodash@3.10.1) ├── i18n-t@1.0.1 (lodash@4.17.21) ├── gitbook-markdown@1.3.2 (kramed-text-renderer@0.2.1, gitbook-html@1.3.3, kramed@0.5.6, lodash@4.17.21) ├── gitbook-asciidoc@1.2.2 (gitbook-html@1.3.3, asciidoctor.js@1.5.5-1, lodash@4.17.21) ├── send@0.13.2 (fresh@0.3.0, etag@1.7.0, statuses@1.2.1, range-parser@1.0.3, ms@0.7.1, depd@1.1.2, mime@1.3.4, debug@2.2.0, http-errors@1.3.1, on-finished@2.3.0) ├── fresh-require@1.0.3 (is-require@0.0.1, shallow-copy@0.0.1, astw@1.3.0, acorn@0.9.0, sleuth@0.1.1, escodegen@1.14.3, through2@0.6.5) ├── rmdir@1.2.0 (node.flow@1.2.3) ├── request@2.72.0 (tunnel-agent@0.4.3, aws-sign2@0.6.0, forever-agent@0.6.1, oauth-sign@0.8.2, is-typedarray@1.0.0, caseless@0.11.0, stringstream@0.0.6, aws4@1.11.0, isstream@0.1.2, json-stringify-safe@5.0.1, tough-cookie@2.2.2, node-uuid@1.4.8, qs@6.1.2, hawk@3.1.3, combined-stream@1.0.8, mime-types@2.1.34, http-signature@1.1.1, form-data@1.0.1, bl@1.1.2, har-validator@2.0.6) ├── read-installed@4.0.3 (debuglog@1.0.1, util-extend@1.0.3, slide@1.1.6, readdir-scoped-modules@1.1.0, read-package-json@2.1.2) ├── cpr@1.1.1 (rimraf@2.4.5) ├── tiny-lr@0.2.1 (parseurl@1.3.3, livereload-js@2.4.0, qs@5.1.0, debug@2.2.0, faye-websocket@0.10.0, body-parser@1.14.2) ├── cheerio@0.20.0 (entities@1.1.2, lodash@4.17.21, css-select@1.2.0, htmlparser2@3.8.3, jsdom@7.2.2) ├── juice@2.0.0 (deep-extend@0.4.2, slick@1.12.2, batch@0.5.3, cssom@0.3.1, cross-spawn-async@2.2.5, commander@2.9.0, web-resource-inliner@2.0.0) ├── chokidar@1.5.0 (async-each@1.0.3, path-is-absolute@1.0.1, inherits@2.0.4, glob-parent@2.0.0, is-glob@2.0.1, is-binary-path@1.0.1, anymatch@1.3.2, readdirp@2.2.1) └── nunjucks@2.5.2 (asap@2.0.6, yargs@3.32.0, chokidar@1.7.0) GitBook version: 3.2.3 3. gitbook 创建 $ mkdir gitbook-demo $ cd gitbook-demo #使用 gitbook init 初始化书籍目录 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished $ ls README.md SUMMARY.md #使用 gitbook build 编译书籍 $ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.4s ! $ ls _book README.md SUMMARY.md $ ls _book/ gitbook index.html search_index.json $ ls _book/gitbook/ fonts gitbook.js gitbook-plugin-fontsettings gitbook-plugin-highlight gitbook-plugin-lunr gitbook-plugin-search gitbook-plugin-sharing images style.css theme.js #使用 gitbook serve 编译并预览书籍 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 0.5s ! Starting server ... Serving book on http://localhost:4000 效果 图中侧栏Introduction的内容正是README.md的内容，SUMMARY.md 是编写界面侧栏的目录结构。 $ cat README.md # Introduction $ cat SUMMARY.md # Summary * [Introduction](README.md) Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-17 16:47:05 "},"Gitbook/3_Gitbook_README.html":{"url":"Gitbook/3_Gitbook_README.html","title":"3 Gitbook README","keywords":"","body":"Gitbook README.md1. 自述和介绍2. 其他文件替代 README.mdGitbook README.md 1. 自述和介绍 书本的首页内容默认是从文件 README.md 中提取的。 README.md是 gitbook 最基础的文件之一，它一般用来描述这本书最基本的信息。 它呈现给读者这本书最初的样子，如果内容不够简洁明了，很可能就没有看下去的欲望了。 可以通过 gitbook init 自动创建该文件。 如果这个文件名没有出现在 SUMMARY.md (目录索引文件) 中，那么它会被添加为章节的第一个条目。 2. 其他文件替代 README.md 一些项目更愿意将 README.md 文件作为项目的介绍而不是书的介绍。 大部分代码托管平台将 README.md 自动显示到项目首页，如果你不喜欢这样。 从GitBook >2.0.0 起，就可以在 book.json 中定义某个文件作为README。 book.json { \"structure\" : { \"readme\" : \"information.md\" } } Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/4_Gitbook_SUMMARY.html":{"url":"Gitbook/4_Gitbook_SUMMARY.html","title":"4 Gitbook SUMMARY","keywords":"","body":"Gitbook SUMMARY.md1. 简介2. 多级目录实现3. 标题和水平线5. gruntGitbook SUMMARY.md 1. 简介 GitBook默认使用SUMMARY.md文件实现目录结构的设定，在该文件中，可以通过缩进实现多级目录的效果，如： # Summary * [第一章](section1/README.md) * [第一节](section1/example1.md) * [第二节](section1/example2.md) * [第二章](section2/README.md) * [第一节](section2/example1.md) 但是有个问题：gitbook默认只支持两层的导航栏，在遇到内容比较多需要章节层次比较深时，很不方便。 好在后来gitbook终于提供了多级导航栏的支持。 2. 多级目录实现 bui# Summary * [介绍](introduction/index.md) * [mercury 信息](introduction/information.md) * [Google Dapper](dapper/index.md) * [mercury实现](implementation/index.md) 要实现一个多级的导入栏很简单，就改动两个地方： 第一行从 “# Summary” 修改为 “bui# Summary” 章节的层次结构按照原来的格式要求继续缩进 3. 标题和水平线 也可以通过使用标题或者水平线标识将GitBook目录分为几个不同的部分： # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) 5. grunt 为了方便发布到github，我选择了使用grunt。 同样为了支持多层导航栏，grunt相关的插件也需要使用新版本。 具体需要修改package.js中的以下内容，目前最新的版本是这样： \"devDependencies\": { \"grunt\": \"~0.4.5\", \"grunt-gitbook\": \"~1.5.0\", \"grunt-gh-pages\": \"~0.10.0\", \"grunt-contrib-clean\": \"~0.6.0\", \"grunt-http-server\": \"~1.4.0\" }, \"peerDependencies\": { \"grunt\": \"~0.4.5\" } 对于旧有项目，为了更新插件版本，可以先删除原来已经安装的插件后重新安装： rm -rf node_modules/* npm install Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/5_Gitbook_book.json.html":{"url":"Gitbook/5_Gitbook_book.json.html","title":"5_Gitbook_book.json","keywords":"","body":"Gitbook book.json1. 简介2. 通用配置3. 插件配置4. 结构配置5. PDF配置6. 简单示例7. demoGitbook book.json 1. 简介 配置 GitBook 允许您使用灵活的配置自定义您的书。这些选项在book.json文件中指定。 2. 通用配置 配置名 描述 root 包含所有图书文件的根文件夹的路径，除了book.json structure 要指定自述文件、摘要、词汇表等的路径。请参阅结构段落。 title 您的书名，默认值是从 README 中提取的。在 legacy.gitbook.com 上，此字段已预先填写。 description 你的书的描述，默认值是从自述文件中提取的。在 legacy.gitbook.com 上，此字段已预先填写。 author 作者姓名。在 legacy.gitbook.com 上，此字段已预先填写。 isbn 书的 ISBN language 书籍语言的ISO 代码，默认值为en direction 文本的方向。可以是rtl或ltr，默认值取决于language gitbook 应该使用的 GitBook 版本。使用SemVer规范并接受如下条件\">= 3.0.0\" 3. 插件配置 配置名 描述 plugins 要加载的插件列表 pluginsConfig 插件的配置 4. 结构配置 除了root变量之外，您还可以告诉 Gitbook 自述文件、摘要、词汇表、语言的文件名称（而不是使用默认名称，例如README.md）。这些文件必须位于您书籍的根目录（或每本语言书籍的根目录）。dir/MY_README.md不接受诸如此类的路径。 配置名 描述 structure.readme 自述文件名（默认为README.md） structure.summary 摘要文件名（默认为SUMMARY.md） structure.glossary 词汇表文件名（默认为GLOSSARY.md） structure.languages 语言文件名（默认为LANGS.md） 5. PDF配置 PDF 输出可以使用以下中的一组选项进行自定义book.json： |多变的 |描述| |--|--| | pdf.pageNumbers| 在每页底部添加页码（默认为true） | |pdf.fontSize |基本字体大小（默认为12） | |pdf.fontFamily |基本字体系列（默认为Arial） | |pdf.paperSize |纸张大小，选项为'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'legal', 'letter'（默认为a4）| | pdf.margin.top |上边距（默认为56） | |pdf.margin.bottom |下边距（默认为56）| |pdf.margin.right |右边距（默认为62）| |pdf.margin.left| 左边距（默认为62）| 6. 简单示例 gitbook 在编译书籍的时候会读取书籍源码顶层目录中的 book.js或者 book.json，这里以 book.json 为例. { // Folders to use for output // Caution: it overrides the value from the command line // It's not advised this option in the book.json \"output\": null, // Generator to use for building // Caution: it overrides the value from the command line // It's not advised this option in the book.json \"generator\": \"site\", // Book metadats (somes are extracted from the README by default) \"title\": null, \"description\": null, \"isbn\": null, // For ebook format, the extension to use for generation (default is detected from output extension) // \"epub\", \"pdf\", \"mobi\" // Caution: it overrides the value from the command line // It's not advised this option in the book.json \"extension\": null, // Plugins list, can contain \"-name\" for removing default plugins \"plugins\": [], // Global configuration for plugins \"pluginsConfig\": { \"fontSettings\": { \"theme\": \"sepia\", \"night\" or \"white\", \"family\": \"serif\" or \"sans\", \"size\": 1 to 4 } }, // Variables for templating \"variables\": {}, // Links in template (null: default, false: remove, string: new value) \"links\": { // Custom links at top of sidebar \"sidebar\": { \"Custom link name\": \"https://customlink.com\" }, // Sharing links \"sharing\": { \"google\": null, \"facebook\": null, \"twitter\": null, \"weibo\": null, \"all\": null } }, // Options for PDF generation \"pdf\": { // Add page numbers to the bottom of every page \"pageNumbers\": false, // Font size for the fiel content \"fontSize\": 12, // Paper size for the pdf // Choices are [u’a0’, u’a1’, u’a2’, u’a3’, u’a4’, u’a5’, u’a6’, u’b0’, u’b1’, u’b2’, u’b3’, u’b4’, u’b5’, u’b6’, u’legal’, u’letter’] \"paperSize\": \"a4\", // Margin (in pts) // Note: 72 pts equals 1 inch \"margin\": { \"right\": 62, \"left\": 62, \"top\": 36, \"bottom\": 36 }, //Header HTML template. Available variables: _PAGENUM_, _TITLE_, _AUTHOR_ and _SECTION_. \"headerTemplate\": null, //Footer HTML template. Available variables: _PAGENUM_, _TITLE_, _AUTHOR_ and _SECTION_. \"footerTemplate\": null } } 首先，将book.json放到书籍代码顶层目录中，然后编译书籍： $ gitbook build 可以看到，编译完成，使用 $ gitbook serve 然后将浏览器指向 http://127.0.0.1:4000，可以看到，什么都没有改变！ 是的，虽然这里 book.json 文件非法，但是 gitbook build 并没有报错！ &#x1F4A1; ConfigurationError: Error with book's configuration: config.isbn is not of a type(s) string 所以，用户需要自己准备工具来保证 book.json 必须是一个合法的 JSON 文件，并且不能含有非法配置项。 首先，删除注释项，以及空行，如果是在 vim 中，可以执行下面的命令： :%g/\\s*\\/\\//d :%g/^\\s*$/d 然后，使用 python 来检查 book.json 是否合法，同样，在 vim 中执行下面的命令： :%!python -m json.tool 很显然，下面的配置不能通过，所以删去（注：但是默认主题却是使用的这个配置！）。 \"pluginsConfig\": { \"fontSettings\": { \"theme\": \"sepia\", \"night\" or \"white\", \"family\": \"serif\" or \"sans\", \"size\": 1 to 4 } }, 最后，剩下的内容如下： { \"description\": null, \"extension\": null, \"generator\": \"site\", \"isbn\": null, \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": {} }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": null, \"variables\": {} } 现在，修改一些配置，修改后为： $ cat book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"zongxun's Blog\": \"https://smoothies.com.cn\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": \"Git Handbook\", \"variables\": {} } 7. demo 执行gitbook install 会安装 GitBook 依赖插件 gitbook install book.json配置内容： { \"title\": \"Gitbook Docs\", \"author\": \"宗勋 - zongxun\", \"description\": \"这是一本关于Git、Github、Gitlab、Gitbook、GitOps的书籍\", \"language\": \"zh-hans\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"zongxun's Blog\": \"https://smoothies.com.cn\" } }, \"plugins\": [ \"3-ba\", \"accordion\", \"advanced-emoji\", \"anchor-navigation-ex\", \"baidu-tongji\", \"code\", \"change_girls\", \"custom-favicon\", \"donate\", \"chapter-fold\", \"edit-link\", \"flexible-alerts\", \"github-buttons\", \"github\", \"lightbox\", \"insert-logo\", \"musicxml\", \"prism\", \"pageview-count\", \"-highlight\", \"-search\", \"-lunr\", \"rss\", \"search-plus\", \"splitter\", \"-sharing\", \"sharing-plus\", \"sidebar-style\", \"theme-comscore\", \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/Ghostwritten\" }, \"github-buttons\": { \"buttons\": [ { \"user\": \"Ghostwritten\", \"repo\": \"gitbook-docs\", \"type\": \"star\", \"count\": true, \"size\": \"small\" } ] }, \"change_girls\" : { \"time\" : 10, \"urls\" : [ \"https://www.bizhishe.com/d/file/2019-08-26/1566827846505876.jpg\", \"https://www.bizhishe.com/d/file/2019-07-24/1563977671157231.jpg\", \"https://www.bizhishe.com/d/file/2019-07-14/1563116649970786.jpg\" ] }, \"chapter-fold\":{}, \"favicon\": \"assets/imgs/1_girl.ico\", \"donate\": { \"button\": \"打赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\", \"alipay\": \"https://github.com/Ghostwritten/gitbook-docs/blob/gh-pages/assets/imgs/aplipay.png?raw=true\", \"wechat\": \"https://github.com/Ghostwritten/gitbook-docs/blob/gh-pages/assets/imgs/wechat.png?raw=true\" }, \"edit-link\": { \"base\": \"https://github.com/Ghostwritten/gitbook-docs/edit/master/\", \"label\": \"Edit\" }, \"prism\": { \"lang\": { \"shell\": \"bash\" } }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy ghostwritten 浙ICP备2020032454号 2022\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"baidu-tongji\": { \"token\": \"55e7dfe47f4dc1c018d4042fdfa62565\" }, \"anchor-navigation-ex\": { \"showLevel\": false }, \"sidebar-style\": { \"title\": \"《Gitbook Docs》\", \"author\": \"zongxun\" }, \"flexible-alerts\": { \"note\": { \"label\": \"Note\" }, \"tip\": { \"label\": \"Tip\" }, \"warning\": { \"label\": \"Warning\" }, \"danger\": { \"label\": \"Danger\" } }, \"3-ba\": { \"token\": \"9ffc0dce8d7079aceab6b0bc18eb626b\" }, \"insert-logo\": { \"url\": \"https://www.bizhishe.com/d/file/2019-07-14/1563116649268975.jpg\", \"style\": \"background: none; max-height: 100px; min-height: 100px\" }, \"rss\": { \"title\": \"Gitbook Docs\", \"description\": \"This is the best book ever.\", \"author\": \"Zong Xun\", \"site_url\": \"https://smoothies.com.cn/gitbook-docs/\", \"managingEditor\": \"writer@smoothies.com.cn (Zong Xun)\", \"webMaster\": \"webmaster@smoothies.com.cn (Zong Xun)\", \"categories\": [ \"gitbook\" ] }, \"sharing\": { \"douban\": false, \"facebook\": true, \"google\": false, \"pocket\": false, \"qq\": false, \"qzone\": false, \"twitter\": true, \"weibo\": false, \"all\": [ \"facebook\", \"google\", \"twitter\" ] } } } 效果： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitbook/6_Gitbook_push_Github_Pages.html":{"url":"Gitbook/6_Gitbook_push_Github_Pages.html","title":"6 Gitbook Push Github Pages","keywords":"","body":"Gitbook 发布 Github Pages1. github 创建仓库2. 本地创建github仓库2.1 linux3. 配置 github pages3.1 新建分支3.2 删除不需要的文件3.3 添加忽略文件3.4 复制_book文件夹到分支根目录3.5 推送3.6 验证4. 推送至gitbook仓库5. github action：master 同步 gh-pages5.1 新建 Person Access Token5.2 创建 secret5.3 编写 .github/workflows/main.yml5.4 推送 github5.5 验证Gitbook 发布 Github Pages 1. github 创建仓库 例如：git-handbook 2. 本地创建github仓库 2.1 linux 仓库名：git-handbook 初始化配置操作，推送github pages $ mkdir git-handbook $ cd git-handbook $ gitbook init $ gitbook build $ ls _book/ gitbook index.html search_index.json $ ls _book README.md SUMMARY.md $ git init $ echo \"*~\" > .gitignore $ echo \"_book\" >> .gitignore $ git add --all $ git commit -m \"Publish book\" $ git remote add origin https://github.com/Ghostwritten/git-handbook.git $ git push -u origin master Username for 'https://github.com': ghostwritten Password for 'https://ghostwritten@github.com': 3. 配置 github pages 3.1 新建分支 git checkout --orphan gh-pages 3.2 删除不需要的文件 切换到pages分支后，我们需要将_books目录之外的文件都清理掉： git rm --cached -r . git clean -df rm -rf *~ 3.3 添加忽略文件 使用文本编辑器，创建名为.gitignore的文件，内容如下： *~ _book .DS_Store 通过.gitignore文件，本地仓库将忽略临时文件和_book文件夹。 3.4 复制_book文件夹到分支根目录 cp -r _book/* . 3.5 推送 git add . git commit -m '更新说明' git push -u origin gh-pages master与gh-pages的不同之处： 3.6 验证 如果没有自定义的域名，你访问的方式地址为：http://.github.io/git-handbook 这里我配置了自己的域名，ghostwritten*.github.io* 重定向到了个人站点 smoothies.com.cn 4. 推送至gitbook仓库 注册gitbook 与仓库同名 5. github action：master 同步 gh-pages 5.1 新建 Person Access Token 复制Person Access Token 5.2 创建 secret 创建secret：ACTIONS_DEPLOY_KEY ，value填写Person Access Token 5.3 编写 .github/workflows/main.yml name: auto-generate-gitbook on: #在master分支上进行push时触发 push: branches: - master jobs: main-to-gh-pages: runs-on: ubuntu-latest steps: - name: checkout master uses: actions/checkout@v2 with: ref: master - name: install nodejs uses: actions/setup-node@v1 - name: configue gitbook run: | npm install -g gitbook-cli gitbook install npm install -g gitbook-summary - name: generate _book folder run: | book sm gitbook build cp SUMMARY.md _book - name: push _book to branch gh-pages env: TOKEN: ${{ secrets.ACTIONS_DEPLOY_KEY }} REF: github.com/${{ github.repository }}.git MYEMAIL: 1zoxun1@gmail.com # ！！记得修改为自己github设置的邮箱 MYNAME: ${{ github.repository_owner }} run: | cd _book git config --global user.email \"${MYEMAIL}\" git config --global user.name \"${MYNAME}\" git init git remote add origin https://${REF} git add . git commit -m \"Updated By Github Actions With Build ${{github.run_number}} of ${{github.workflow}} For Github Pages\" git branch -M master git push --force --quiet \"https://${TOKEN}@${REF}\" master:gh-pages 5.4 推送 github git add . git commit -m \"update **[.github](https://github.com/rootsongjc/kubernetes-handbook/tree/master/.github)/[workflows](https://github.com/rootsongjc/kubernetes-handbook/tree/master/.github/workflows)/main.yml**\" git push origin master 5.5 验证 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-10 03:40:20 "},"Gitbook/7_Gitbook_Update_Github_Pages.html":{"url":"Gitbook/7_Gitbook_Update_Github_Pages.html","title":"7 Gitbook Update Github Pages","keywords":"","body":"Gitbook 持续更新 Github Pages1. 新增 md2. 定制 book.json3. 脚本发布Gitbook 持续更新 Github Pages 1. 新增 md $ ls _book gitbook index.html README.md search_index.json SUMMARY.md $ ls _book/ gitbook index.html search_index.json 新增Gihub目录，以及文章 $ ls _book gitbook Github index.html README.md search_index.json SUMMARY.md $ ls Github/ 1_github_introduce.md 2_github_local_pull_github.md 3_github_action.md 4_github_page.md 2. 定制 book.json 或许偶尔你会手动更新book.json,比如：新增插件、分享链接等等。 $ cat book.json { \"author\": \"zongxun \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"zongxun's Blog\": \"https://smoothies.com.cn\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": \"Git Handbook\", \"variables\": {} } $ ls _book book.json gitbook Github index.html README.md search_index.json SUMMARY.md 更多细节请参考pages定制 3. 脚本发布 新建 Person Access Token 复制token #!/bin/bash # author: ghostwritten # date: 01/06 2022 # description: deploy Github Pages # ############################################################################## set -o nounset FILE_NAME=\"update.sh\" FILE_VERSION=\"v1.0\" BASE_DIR=\"$( dirname \"$( readlink -f \"${0}\" )\" )\" if [ $# != 1 ] ; then echo \"USAGE: $0 something \" echo \" e.g.: $0 update github pages\" exit 1; fi update=$1 #token=$2 user='Ghostwritten' email='1zoxun1@gmail.com' repo=\"github.com/${user}/gitbook-docs.git\" book sm python3 gitbook-auto-summary.py . dirs=`grep -E '\\- ' SUMMARY-GitBook-auto-summary.md | awk '{print $2}'` for dir in $dirs do dir_README=`grep -E \"\\[${dir}\\]\" SUMMARY.md | sed 's/^[ \\t]*//g'` dir_README=${dir_README//\\//\\\\\\/} dir_README=${dir_README//\\[/\\\\[} dir_README=${dir_README//\\]/\\\\]} dir_README=${dir_README//\\(/\\\\\\(} dir_README=${dir_README//\\)/\\\\\\)} dir_README=${dir_README//\\-/\\\\\\-} sed -r -i \"s#\\\\- ${dir}\\$#$dir_README#g\" SUMMARY-GitBook-auto-summary.md done cp -r SUMMARY-GitBook-auto-summary.md SUMMARY.md gitbook build git remote add origin https://${repo} git add . git commit -m \"${update}\" git push origin master cd _book git init git remote add origin https://${repo} git add . git commit -m \"${update} For Github Pages\" git branch -M master git push --force --quiet \"https://${TOKEN}@${repo}\" master:gh-pages 执行： $ bash deploy.sh \"update \" Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/":{"url":"Github/","title":"Github","keywords":"","body":"github 介绍github是什么GitHub与Git关系github创建项目如何用好 GitHub敏捷软件开发git提交规范工作写法常规写法开源应用、开源库写法github 介绍 github是什么 GitHub 是一个共享虚拟主机服务，用于存放使用Git版本控制的软件代码和内容项目。它由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。 它还是什么? 网站 免费博客 管理配置文件 收集资料 简历 管理代码片段 托管编程环境 写作 版本管理与软件部署 GitHub与Git关系 Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取 得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被 诸如Capistrano和Vlad the Deployer这样的部署工具所使用。 GitHub可以托管各种git库，并提供一个web界面，但与其它像 SourceForge或Google Code这样的服务不同，GitHub的独特卖 点在于从另外一个项目进行分支的简易性。为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将 修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并。已经有人将GitHub称为代码 玩家的MySpace。 github创建项目 git本地项目上传github或gitlab详解 如何用好 GitHub 如何用好 GitHub，并实践一些敏捷软件开发是一个很有意思的事情.我们可以在上面做很多事情,从测试到CI,再到自动部署. 敏捷软件开发 瀑布流是怎样的？ 一个项目的组成： 代码 CI 测试 自动化测试 文档 版本管理 自动部署 代码模块化 自动化测试 代码质量与重构 git提交规范 工作写法 格式 [任务卡号] xx & xx: do something 比如： [PHODAL-0001] ladohp & phodal: update documents ，解释如下： PHODAL-0001 ，业务的任务卡号，它可以帮我们找到某个业务修改的原因，即点出相应 bug 的来源 ladohp & phodal ，结对编程的两个人的名字，后者（phodal）一般是写代码的人，出于礼貌就放在后面了。由于 Git的提交人只显示一个，所以写上两个的名字。当提交的人不在时，就可以问另外一个人修改的原因。 update documents ，我们做了什么事情 缺点：而对于采用看板的团队来说，并不存在任务卡号这种东西，因此就需要一种额外的作法。 常规写法 格式 [任务分类] 主要修改组件（可选）：修改内容 示例 1， [T] tabs: add icons 。其中的 T 表示这是一个技术卡， tabs 表示修改的是Tabs， add icons 则表示添加了图标。 示例 2， [SkillTree] detail: add link data 。其中的 SkillTree 表示修改的是技能树 Tab 下的内容， detail 则表示修改的是详情页， add link data 则表示是添加了技能的数据 这样做的主要原因是，它可以轻松也帮我 filter 出相应业务的内容。 缺点：要这样做需要团队达到一致，因此付出一些额外的成本。 开源应用、开源库写法 与我们日常工作稍有不同的是：工作中的 Release 计划一般都是事先安排好的，不需要一些CHANGELOG 什么的。而开源应用、开源库需要有对应的 CHANELOG，则添加了什么功能、修改了什么等等。毕竟有很多东西是由社区来维护的。 诸如： docs(changelog): update change log to beta.5 中： docs 则对应修改的类型 changelog 则是影响的范围 subject 则是对应做的事件 对应的类型有： build: 影响构建系统或外部依赖关系的更改（示例范围：gulp，broccoli，npm） ci: 更改我们的持续集成文件和脚本（示例范围：Travis，Circle，BrowserStack，SauceLabs） docs: 仅文档更改 feat: 一个新功能 fix: 修复错误 perf: 改进性能的代码更改 refactor: 代码更改，既不修复错误也不添加功能 style: 不影响代码含义的变化（空白，格式化，缺少分号等） test: 添加缺失测试或更正现有测试 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/1_Github_Create_Depository.html":{"url":"Github/1_Github_Create_Depository.html","title":"1 Github Create Depository","keywords":"","body":"Github 创建仓库1. 简介2. 创建仓库3. 提交您的第一个更改4. fork 仓库5. clone 仓库Github 创建仓库 1. 简介 您可以在 GitHub 仓库中存储各种项目，包括开源项目。 通过开源项目，您可以共享代码以开发更好、更可靠的软件。 您可以使用仓库与他人协作并跟踪您的工作。 2. 创建仓库 在任何页面的右上角，使用 下拉菜单选择 New repository（新建仓库）。 为仓库键入简短、令人难忘的名称。 例如 \"hello-world\"。 （可选）添加仓库的说明。 例如，“我在 GitHub 上的第一个仓库”。 选择仓库可见性。 选择 Initialize this repository with a README 单击 Create repository（创建仓库）。 3. 提交您的第一个更改 创建新仓库时，您使用自述文件对其进行了初始化。 自述文件是详细介绍项目的好工具，您也可以添加一些文档，例如介绍如何安装或使用项目的文档。 自述文件的内容自动显示在仓库的首页上。 在仓库的文件列表中，单击 README.md。 在 Edit file（编辑文件）选项卡上，键入一些关于您自己的信息。 在新内容上方，单击 Preview changes（预览更改）。 查看您对文件所做的更改。 您将看到绿色的新内容。 在页面底部，输入一条简短、有意义的提交消息，描述您对文件所作的更改。 在提交消息字段下面，确定是要将提交添加到当前分支还是新分支。 如果当前分支是默认分支，则应选择为提交创建新分支，然后创建拉取请求。 单击 Propose file change（提议文件更改）。 4. fork 仓库 复刻是仓库的副本。 通过复刻仓库，您可以自由地尝试更改而不会影响原始项目。将其他人的项目用作自己创意的起点。 例如，可以使用复刻提出与修复 Bug 相关的更改。 无需为您发现的漏洞创建议题，您可以： fork 仓库 进行修复 向项目所有者提交拉取请求。 5. clone 仓库 命令行 要使用 HTTPS 克隆仓库，在“HTTPS”下单击 。 要使用 SSH 密钥克隆仓库，包括组织的 SSH 认证中心颁发的证书，单击 SSH，然后单击 。 要使用 GitHub CLI 克隆存储库，请单击 GitHub CLI，然后单击。 git clone https://github.com/Ghostwritten/gitbook-demo.git Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/2_Github_Local_Pull_Github.html":{"url":"Github/2_Github_Local_Pull_Github.html","title":"2 Github Local Pull Github","keywords":"","body":"Github 托管1 安装与配置2. 界面创建github3 创建仓库上传github或gitlab4. 上传本地项目到github或gitlab5. 解决错误Github 托管 1 安装与配置 1.win下载git工具：git bash 、git gui 、git cmd https://git-scm.com/downloads linux环境下如果yum源有git包， yum -y install git-all.noarch 若没有还是去官网下载。 2.打开git bash，执行以下命令，配置git的用户名与邮箱 $ git config --global user.name \"hanyuntao\" $ git config --global user.email \"hanyuntaocn@163.com\" $ git config --list 3。 设置SSH key（git中sshkey有何作用？） 首先检查是否已生成密钥cd ~/.ssh，如果返回的ls有3个文件,则密钥已经生成。 $ ssh-keygen -t rsa -C \"hanyuntaocn@163.com\" 生成密钥 把id_rsa.pub的公钥内容复制 ，然后找到github的用户设置的列表中SSH and GPG keys选项，添加 new SSH key，随便起个名字，粘贴复制公钥。 ssh -T git@github.com #远程登录git 2. 界面创建github 3 创建仓库上传github或gitlab 非常简单，起名字，描述库的作用功能，设置公有，私有。 是否设置创建README，如果之前没有设置它，上传文件就会报错。 否则执行以下命令： git init echo \"# github-roam\" >> README.md git add README.md git commit -m 'first_commit' git remote add origin https://github.com/findingsea/myRepoForBlog.git git push origin master 4. 上传本地项目到github或gitlab cd d:test #某一个文件目录 git init #初始化为库 git add . #添加上传内容 ,如果报错，尝试git add --all git commit -m \"test four\" #编写描述内容 git remote #查看远程主机名（一个远程库伪主机的主机名） git remote add origin https://github.com/Ghostwritten/tutorial.git 添加远程库名 git push origin master #推送到库 5. 解决错误 错误1 1.To https://github.com/Ghostwritten/test.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'https://github.com/Ghostwritten/test.git' git push origin master --force #强制推送到库名下 错误2 git remote add origin https://github.com/findingsea/myRepoForBlog.git，出现错误： 　　fatal: remote origin already exists 则执行以下语句： git remote rm origin git remote add origin https://github.com/findingsea/myRepoForBlog.git 错误3 在执行git push origin master时，报错： error:failed to push som refs to....... 则执行以下语句： git pull origin master 先把远程服务器github上面的文件拉先来，再push 上去。 可以看到我们的本地项目已经上传到了github上了。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/3_Github_Manage_Remote_Repositories.html":{"url":"Github/3_Github_Manage_Remote_Repositories.html","title":"3 Github Manage Remote Repositories","keywords":"","body":"github 管理远程仓库1. 简介2. 添加远程仓库3. 更改远程仓库的 URL4. 重命名远程仓库5. 删除远程仓库github 管理远程仓库 1. 简介 GitHub 的协作开发方法取决于将提交从本地存储库发布到 GitHub 以供其他人查看、获取和更新 您只能推送到两种类型的 URL 地址： HTTPS URL，如https://github.com/user/repo.git SSH URL，例如git@github.com:user/repo.git Git 将远程 URL 与名称相关联，您的默认远程通常称为origin. 2. 添加远程仓库 $ git remote add origin https://github.com/user/repo.git # Set a new remote $ git remote -v # Verify new remote > origin https://github.com/user/repo.git (fetch) > origin https://github.com/user/repo.git (push) 3. 更改远程仓库的 URL 将远程 URL 从 SSH 切换到 HTTPS $ git remote -v > origin git@github.com:USERNAME/REPOSITORY.git (fetch) > origin git@github.com:USERNAME/REPOSITORY.git (push) #使用 git remote set-url 命令将远程的 URL 从 SSH 更改为 HTTPS。 $ git remote set-url origin https://github.com/USERNAME/REPOSITORY.git $ git remote -v # Verify new remote URL > origin https://github.com/USERNAME/REPOSITORY.git (fetch) > origin https://github.com/USERNAME/REPOSITORY.git (push) 将远程 URL 从 HTTPS 切换到 SSH $ git remote -v > origin https://github.com/USERNAME/REPOSITORY.git (fetch) > origin https://github.com/USERNAME/REPOSITORY.git (push) $ git remote set-url origin git@github.com:USERNAME/REPOSITORY.git $ git remote -v # Verify new remote URL > origin git@github.com:USERNAME/REPOSITORY.git (fetch) > origin git@github.com:USERNAME/REPOSITORY.git (push) 4. 重命名远程仓库 $ git remote -v # 查看现有远程 > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push) $ git remote rename origin destination # 将远程名称从 'origin' 更改为 'destination' $ git remote -v # 验证远程的新名称 > destination https://github.com/OWNER/REPOSITORY.git (fetch) > destination https://github.com/OWNER/REPOSITORY.git (push) 5. 删除远程仓库 $ git remote -v # 查看当前远程 > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push) > destination https://github.com/FORKER/REPOSITORY.git (fetch) > destination https://github.com/FORKER/REPOSITORY.git (push) $ git remote rm destination # 删除远程 $ git remote -v # 验证其已删除 > origin https://github.com/OWNER/REPOSITORY.git (fetch) > origin https://github.com/OWNER/REPOSITORY.git (push) 注意：git remote rm 不会从服务器中删除远程存储库。 它只是从本地仓库中删除远程及其引用。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/4_Github_Delete_folders_remotely.html":{"url":"Github/4_Github_Delete_folders_remotely.html","title":"4 Github Delete Folders Remotely","keywords":"","body":"GitHub 远程删除文件夹方法一方法二GitHub 远程删除文件夹 方法一 这里以删除 .setting 文件夹为案例 $ git rm -r --cached .setting #--cached不会把本地的.setting删除 $ git commit -m 'delete .setting dir' $ git push -u origin master 方法二 如果误提交的文件夹比较多，方法一也较繁琐 直接修改.gitignore文件,将不需要的文件过滤掉，然后执行命令 $ git rm -r --cached . $ git add . $ git commit $ git push -u origin master Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/5_Github_Delete_local_and_remote_branches.html":{"url":"Github/5_Github_Delete_local_and_remote_branches.html","title":"5 Github Delete Local And Remote Branches","keywords":"","body":"Github 删除本地与远程分支Github 删除本地与远程分支 删除远程分支gh-pages git push origin --delete gh-pages 删除本地分支 git branch -d gh-pages Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/6_Github_Custom_Home_Page.html":{"url":"Github/6_Github_Custom_Home_Page.html","title":"6 Github Custom Home Page","keywords":"","body":"Github 定制主页Github 定制主页 效果图： 第一步：创建一个与账号同名的仓库，我的是Ghostwritten 第二步：提出展示需求 需求： 一个问候语 导入一个风格图片 统计一个信以为真的访问量 展示你的活跃度 介绍一下自己 传递你的博客与公众号 你的工作平台、技能与工具是什么 你的擅长语言对比 你日常关注的大佬 .................... 第三步：编写代码，README.md编写 工具： 牌子渲染服务：https://shields.io/ shields用法 github概要奖牌：https://github.com/ryo-ma/github-profile-trophy 丰富案例（包含各种有趣的展示）：https://github.com/abhisheknaiidu/awesome-github-profile-readme 美化教学 代码示例 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/7_Github_Action_Automatically_Build_Deploy.html":{"url":"Github/7_Github_Action_Automatically_Build_Deploy.html","title":"7 Github Action Automatically Build Deploy","keywords":"","body":"Github Action 自动部署构建1. 简介2. 基础概念3. workflow 文件3.1 触发事件3.2 job任务3.3 运行主机环境3.4 运行步骤3.5 引用action3.6 显示workflow status3.7 with传参3.8 env环境变量3.9 secrets引用3.10 action/checkout检查4. 获取token5. 示例5.1 一条命令的action5.2 React 项目发布到 GitHub PagesGithub Action 自动部署构建 1. 简介 GitHub Actions 是 GitHub 的持续集成服务，于2018年10月推出。 GitHub Actions 帮助您自动完成软件开发周期内的任务。 GitHub Actions 是事件驱动的，意味着您可以在指定事件发生后运行一系列命令。 工作流程是您添加到仓库的自动化过程。 工作流程由一项或多项作业组成，可以计划或由事件触发。 工作流程可用于在 GitHub 上构建、测试、打包、发布或部署项目。 GitHub 官方市场，我们除了自己编写action，也可以借用别人的。 每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。 actions 也有版本的概念，下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。 actions/setup-node@74bc508 # 指向一个 commit actions/setup-node@v1.0 # 指向一个标签 actions/setup-node@master # 指向一个分支 2. 基础概念 workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。 job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务； step（步骤）：每个 job 由多个 step 构成，一步步完成。 action （动作）：每个 step 可以依次执行一个或多个命令（action）。 GitHub Ac­tions 为每个任务 (job) 都提供了一个虚拟机来执行，每台虚拟机都有相同的硬件资源： 2-core CPU 7 GB RAM 内存 14 GB SSD 硬盘空间 使用限制： 每个仓库只能同时支持20个 workflow 并行。 每小时可以调用1000次 GitHub API 。 每个 job 最多可以执行6个小时。 免费版的用户最大支持20个 job 并发执行，macOS 最大只支持5个。 私有仓库每月累计使用时间为2000分钟，超过后$ 0.008/分钟，公共仓库则无限制。 操作系统方面可选择 Win­dows server、Linux、ma­cOS，并预装了大量软件包和工具。 虽然名称叫持续集成，但当所有任务终止和完成时，虚拟环境内的数据会随之清空，并不会持续。即每个新任务都是一个全新的虚拟环境。 3. workflow 文件 GitHub Ac­tions 的配置文件叫做 work­flow 文件（官方中文翻译为 “工作流程文件”），存放在代码仓库的.github/workflows 目录中。work­flow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如 p3terx.yml。一个库可以有多个 work­flow 文件，GitHub 只要发现.github/workflows 目录里面有.yml 文件，就会按照文件中所指定的触发条件在符合条件时自动运行该文件中的工作流程。在 Ac­tions 页面可以看到很多种语言的 work­flow 文件的模版，可以用于简单的构建与测试。 workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。 #name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。 name: GitHub Actions Demo 3.1 触发事件 #push事件触发 workflow。 on: push #on字段也可以是事件的数组。`push`事件或`pull_request`事件都可以触发 `workflow`。 on: [push, pull_request] #只有`master`分支发生`push`事件时，才会触发 workflow on: push: branches: - master #push tag 时触发 on: push: tags: - 'v*' #发布 re­lease 触发 on: release: types: [published] 定时触发 on: schedule: - cron: '0 * * * *' 3.2 job任务 workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。 jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。 #job_id分别是my_first_job和my_second_job jobs: my_first_job: name: My first job my_second_job: name: My second job #`needs`字段指定当前任务的依赖关系，即运行顺序。`job1`必须先于job2完成，而job3等待`job1`和`job2`的完成才能运行 #因此，这个 workflow 的运行顺序依次为：`job1、job2、job3`。 jobs: job1: job2: needs: job1 job3: needs: [job1, job2] 3.3 运行主机环境 runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 ubuntu-latest，ubuntu-18.04或ubuntu-16.04 windows-latest，windows-2019或windows-2016 macOS-latest或macOS-10.14 runs-on: ubuntu-18.04 3.4 运行步骤 #`steps`字段指定每个 `Job` 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。 jobs..steps.name：步骤名称。 jobs..steps.run：该步骤运行的命令或者 action。 jobs..steps.env：该步骤所需的环境变量。 steps: - uses: actions/setup-node@74bc508 # Reference a specific commit - uses: actions/setup-node@v1 # Reference the major version of a release - uses: actions/setup-node@v1.2 # Reference a minor version of a release - uses: actions/setup-node@master # Reference a branch 示例： jobs: build: # Job name is Greeting name: Greeting # This job runs on Linux runs-on: ubuntu-latest steps: # This step uses GitHub's hello-world-javascript-action: https://github.com/actions/hello-world-javascript-action - name: Hello world uses: actions/hello-world-javascript-action@v1 with: who-to-greet: 'Mona the Octocat' id: hello # This step prints an output (time) from the previous step's action. - name: Echo the greeting's time run: echo 'The time was ${{ steps.hello.outputs.time }}.' 3.5 引用action #public repo {owner}/{repo}@{ref} or {owner}/{repo}/{path}@{ref}. #same repo {owner}/{repo}@{ref} or ./path/to/dir |-- hello-world (repository) | |__ .github | └── workflows | └── my-first-workflow.yml | └── actions | |__ hello-world-action | └── action.yml jobs: build: runs-on: ubuntu-latest steps: # This step checks out a copy of your repository. - uses: actions/checkout@v1 # This step references the directory that contains the action. - uses: ../github/actions/hello-world-action #docker container docker://{image}:{tag} 示例： jobs: my_first_job: steps: - name: My first step uses: docker://gcr.io/cloud-builders/gradle - name: Install Dependencies run: npm install shell: bash 3.6 显示workflow status ![](https://github.com/actions/hello-world/workflows/Greet Everyone/badge.svg) 3.7 with传参 firstname ,会被转化为INPUTFIRST_NAME使用 jobs: my_first_job: steps: - name: My first step uses: actions/hello_world@master with: first_name: Mona middle_name: The last_name: Octocat 3.8 env环境变量 steps: - name: Hello world run: echo Hello world $FIRST_NAME $middle_name $Last_Name! env: FIRST_NAME: Mona middle_name: The Last_Name: Octocat 3.9 secrets引用 steps: - name: My first action env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} FIRST_NAME: Mona LAST_NAME: Octocat steps: - name: Hello world action with: # Set the secret as an input super_secret: ${{ secrets.SuperSecret }} env: # Or as an environment variable super_secret: ${{ secrets.SuperSecret }} 3.10 action/checkout检查 https://github.com/actions/checkout 最新版本特性： 提高性能 默认情况下只获取一个提交 脚本验证的 git 命令 身份验证令牌保留在本地 git 配置中 支持SSH 创建本地分支 检出分支时不再分离 HEAD 改进的布局 输入path总是相对于 $GITHUB_WORKSPACE 与容器操作更好地对齐，其中 $GITHUB_WORKSPACE 被映射到 回退到 REST API 下载 当 PATH 中没有 Git 2.18 或更高版本时，将使用 REST API 下载文件 使用作业容器时，使用容器的 PATH 4. 获取token 根据GitHub提供的文档生成密钥，生成好后记得复制下来，要不然再访问页面的时候密钥就不展示了。 # 生成密钥时主要需要开启的权限有 1、rope 下所有权限 2、admin:repo_hook 下所有权限 3、delete_repo 下所有权限 # 主要是关于rope的权限，尽量都开启 要使用Actions功能的仓库的Settings中的Secrets中新增一条 Name为:ACCESS_TOKEN Value为:刚才生成好的密钥 5. 示例 5.1 一条命令的action 下面是一个完整的 workflow 文件的范例。 name: Greeting from Mona on: push jobs: my-job: name: My Job runs-on: ubuntu-latest steps: - name: Print a greeting env: MY_VAR: Hi there! My name is FIRST_NAME: Mona MIDDLE_NAME: The LAST_NAME: Octocat run: | echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME. 示例文件运行截图： 5.2 React 项目发布到 GitHub Pages 下面是一个实例，通过 GitHub Actions 构建一个 React 项目，并发布到 GitHub Pages。最终代码都在这个仓库里面，发布后的参考网址为ghostwritten.github.io/github-actions-demo 第一步：这个示例需要将构建成果发到 GitHub 仓库，因此需要 GitHub 密钥。按照官方文档，生成一个密钥。然后，将这个密钥储存到当前仓库的Settings/Secrets里面。 上图是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是ACCESS_TOKEN。如果你不用这个名字，后面脚本里的变量名也要跟着改。 第二步：本地计算机使用create-react-app，生成一个标准的 React 应用。 $ npx create-react-app github-actions-demo $ cd github-actions-demo 然后，打开package.json文件，加一个homepage字段，表示该应用发布后的根目录（参见官方文档）。 \"homepage\": \"https://[username].github.io/github-actions-demo\", 上面代码中，将[username]替换成你的 GitHub 用户名，参见范例。 第三步，在这个仓库的.github/workflows目录，生成一个 workflow 文件，名字可以随便取，这个示例是ci.yml。 别人的 action：JamesIves/github-pages-deploy-action name: Build and Deploy on: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout &#x1F6CE;️ uses: actions/checkout@v1 - name: Build and Deploy uses: JamesIves/github-pages-deploy-action@releases/v2 env: ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }} ## GitHub 密钥 ACCESS_TOKEN 是在第二步Settings的Secrets中新增时定义的Name,要保持一致 BASE_BRANCH: master # The branch the action should deploy from. BRANCH: gh-pages # The branch the action should deploy to. FOLDER: build # The folder the action should deploy. BUILD_SCRIPT: npm install && npm run-script build # The build script the action should run prior to deploying. 上面这个 workflow 文件的要点如下。 整个流程在master分支发生push事件时触发。 只有一个job，运行在虚拟机环境ubuntu-latest。 第一步是获取源码，使用的 action 是actions/checkout。 第二步是构建和部署，使用的 action 是JamesIves/github-pages-deploy-action。 第二步需要四个环境变量，分别为 GitHub 密钥、发布分支、构建成果所在目录、构建脚本。其中，只有 GitHub密钥是秘密变量，需要写在双括号里面，其他三个都可以直接写在文件里。 第五步，保存上面的文件后，将整个仓库推送到 GitHub。GitHub 发现了 workflow 文件以后，就会自动运行。你可以在网站上实时查看运行日志，日志默认保存30天。 等到 workflow 运行结束，访问 GitHub Page，即https://ghostwritten.github.io/github-actions-demo，会看到构建成果已经发上网了。如果你想知道如何利用github搭建一个博客，请参考。因为我的博客域名为smoothies.com.cn，当访问ghostwritten.github.io会自动跳转smoothies.com.cn。 以后，每次修改后推送源码，GitHub Actions 都会自动运行，将构建产物发布到网页。 参考链接： https://jamesiv.es/ https://github.com/JamesIves https://github.com/JamesIves/github-pages-deploy-action https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Github/8_Github_Open_source_merge_request.html":{"url":"Github/8_Github_Open_source_merge_request.html","title":"8 Github Open Source Merge Request","keywords":"","body":"Github | 制作您的第一个开源合并请求1. 背景2. 前提3. 上手贡献开源Github | 制作您的第一个开源合并请求 1. 背景 开源软件是原始源代码可免费获得并可重新分发和修改的软件。作为一名程序员，我们更感兴趣的是如何为他们的代码库做出贡献。 许多新手发现开源是可怕和令人生畏的。但不要担心，每个伟大的开源贡献者都曾经在你现在所在的地方。 2. 前提 以下是深入开源之前所需的先决条件： 对您选择的至少一种编程语言有很好的理解 版本控制：Git/SVN 和 Github、Bitbucket、Gitlab 学习阅读大的源代码，这样它就不会显得乱七八糟。这篇文章可能会有所帮助。 了解如何使用错误/问题跟踪器 3. 上手贡献开源 Up-for-grads Open Hatch Github: Great for new contributors Firsttimersonly 给定的资源包括不同组织的项目列表，可以根据使用的编程语言、项目类别（例如 Web、数据库等）和难度进行过滤。 发起 Pull Request 的步骤： 一旦您决定了要贡献的存储库或要处理的问题，请按照以下步骤发出您的第一个拉取请求： 阅读 CONTRIBUTING.md 指南（如果存在） 与维护者讨论这个问题，提出问题（如果有的话）并清除疑虑。他们是可爱的人，随时准备提供帮助。您还可以通过他们的 IRC 或邮件列表 ping 他们。 继续并 Fork 存储库 Clone the repo：git clone https://github.com/YOUR_USERNAME/PROJECT.git Add Upstream: git remote add upstream https://github.com/PROJECT_USERNAME/PROJECT.git Create new branch: git checkout -b BRANCH_NAME 代码代码代码：进行必要的更改 推送更改：git push origin BRANCH_NAME 通过 Github 创建拉取请求 其他一些有用的命令： 检查远程链接：git remote -v 检查分支：git branch 删除分支：git branch -D BRANCH_NAME 删除 Github 上的分支：git push origin --delete BRANCH_NAME 现在您所要做的就是等待您的更改被维护者审查并合并（或丢弃）。 当您发现您编写的一段代码每天都被世界各地的人们使用时，您会感觉很好。 另外，您可能想查看GSOC。如果这不能激励您从开源开始，那么没有别的可能。 另请参阅 –如何开始使用开源。 参考： Making your first Open Source Pull Request | Github Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2023-02-22 08:57:47 "},"Gitlab/":{"url":"Gitlab/","title":"Gitlab","keywords":"","body":"Gitlab1. 简介2. 历史3. 特征3.1 优点3.2 缺点Gitlab 1. 简介 Gitlab 是一个开源的Git代码仓库系统，可以实现自托管的Github项目，即用于构建私有的代码托管平台和项目管理系统。系统基于Ruby on Rails开发，速度快、安全稳定。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 2. 历史 GitLab 由Dmitriy Zaporozhets和Valery Sizov于 2011 年 10 月发现。 它是在 MIT 许可下分发的，GitLab 的稳定版本是 10.4，于 2018 年 1 月 22 日发布。 3. 特征 GitLab 免费托管您的（私人）软件项目。 GitLab 是一个管理 Git 存储库的平台。 GitLab 提供免费的公共和私有存储库、问题跟踪和 wiki。 GitLab 是一个在 Git 之上的用户友好的 Web 界面层，它提高了使用 Git 的速度。 GitLab 提供了自己的持续集成(CI) 系统来管理项目，并提供用户界面以及 GitLab 的其他功能。 3.1 优点 GitLab 提供GitLab Community Edition版本供用户定位，他们的代码存在于哪些服务器上。 GitLab 免费提供无限数量的私有和公共存储库。 该片段部分可以从一个项目共享，而不是共享整个项目的代码量小。 3.2 缺点 在推送和拉取存储库时，它不如 GitHub 快。 GitLab 界面在从一个页面切换到另一个页面时需要一些时间。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitlab/1_Gitlab_Get_Started.html":{"url":"Gitlab/1_Gitlab_Get_Started.html","title":"1 Gitlab Get Started","keywords":"","body":"gitlab 开始1. 前提2. 安装gitlab3. 配置gitlab4. 启动gitlab5. GitLab构成5.1 gitlab shell5.2 gitlab workhorse6. gitlab 命令7. gitlab主要目录8. gitlab 仓库管理9. 创建用户create user10. 用户授权（grant user）11. 创建仓库create project12. 配置ssh key13. 推送本地客户端仓库到gitlab14. 克隆gitlab仓库到本地客户端15. 设置分支保护16. Gitlab的备份、恢复、升级16.1 手动备份16.2 定时备份输入命令crontab -e16.3 恢复实践gitlab 开始 1. 前提 jenkins插件地址： http://updates.jenkins-ci.org/download/plugins/ 192.168.211.90 gitlab、jenkins、Maven 192.168.211.91 git、httpd 192.168.211.92 nexus、sonarqube、docker-ce 192.168.211.93 这个是单独的环境，用于测试jenkins和docker的 关闭防火墙 # systemctl disable firewalld.service 关闭NetworkManager # systemctl stop NetworkManager 关闭selinux # cat /etc/selinux/config SELINUX=disabled 安装常用命令 # yum install -y net-tools lrzsz tree screen lsof wget ntpdate 设置时间 # crontab -e 添加 # crontab -l */5 * * * * /usr/sbin/ntpdate time1.aliyun.com 更改时区 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 2. 安装gitlab 1.1 gitlab的安装192.168.211.90 GitHub 和 GitLab 都是基于 web 的 Git 仓库 安装依赖： # yum install curl policycoreutils openssh-server openssh-clients policycoreutils-python -y 下载rpm包 # cd /usr/local/src/ #wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-11.9.1-ce.0.el7.x86_64.rpm # rpm -ivh gitlab-ce-11.9.1-ce.0.el7.x86_64.rpm 3. 配置gitlab gitlab的默认配置文件位于：vim /etc/gitlab/gitlab.rb，修改external_url为本机的IP地址或者一个可以访问到本机的域名 external_url 'http://192.168.211.90' 修改完主配置文件后，使用gitlab-ctl reconfigure重新配置加载gitlab 4. 启动gitlab 重新配置执行成功后，就可以重新启动gitlab # gitlab-ctl restart ok: run: alertmanager: (pid 5060) 1s ok: run: gitaly: (pid 5078) 0s ok: run: gitlab-monitor: (pid 5091) 1s ok: run: gitlab-workhorse: (pid 5114) 0s ok: run: logrotate: (pid 5125) 0s ok: run: nginx: (pid 5132) 1s ok: run: node-exporter: (pid 5216) 0s ok: run: postgres-exporter: (pid 5227) 1s ok: run: postgresql: (pid 5238) 0s ok: run: prometheus: (pid 5246) 1s ok: run: redis: (pid 5260) 0s ok: run: redis-exporter: (pid 5430) 0s ok: run: sidekiq: (pid 5439) 0s ok: run: unicorn: (pid 5451) 0s 在浏览器里输入：http://192.168.211.90/，首次登陆要求重设root密码 更改密码成功后 登陆即可 5. GitLab构成 gitlab由以下服务构成，他们共同承担了gitlab的运作需要 Nginx：静态的web服务器 gitlab-shell：用于处理git命令和修改authorized keys列表 gitlab-workhorse：轻量级的反向代理服务器 logrotate：日志文件管理工具 postgresql：数据库 redis：缓存数据库 sidekiq：用于在后台执行队列任务（异步执行） unicorn：An HTTP server for Rack application，gitlab rails应用是托管在这个服务器上面的 可以使用命令来查看各个服务的状态 # gitlab-ctl status run: alertmanager: (pid 5060) 53429s; run: log: (pid 4308) 53665s run: gitaly: (pid 5078) 53428s; run: log: (pid 3570) 53739s run: gitlab-monitor: (pid 5091) 53428s; run: log: (pid 4171) 53683s run: gitlab-workhorse: (pid 5114) 53427s; run: log: (pid 3939) 53700s run: logrotate: (pid 5125) 53427s; run: log: (pid 4017) 53693s run: nginx: (pid 5132) 53427s; run: log: (pid 3967) 53699s run: node-exporter: (pid 5216) 53427s; run: log: (pid 4130) 53688s run: postgres-exporter: (pid 5227) 53427s; run: log: (pid 4356) 53660s run: postgresql: (pid 5238) 53426s; run: log: (pid 3660) 53735s run: prometheus: (pid 5246) 53426s; run: log: (pid 4242) 53672s run: redis: (pid 5260) 53425s; run: log: (pid 3387) 53746s run: redis-exporter: (pid 5430) 53425s; run: log: (pid 4210) 53678s run: sidekiq: (pid 5439) 53424s; run: log: (pid 3906) 53705s run: unicorn: (pid 5451) 53423s; run: log: (pid 3875) 53709s 5.1 gitlab shell Gitlab Shell有两个作用：为Gitlab处理git命令、修改authorized keys列表。 当通过ssh访问gitlab server 时，gitlab shell会： 调用gitlab rails api检查权限 执行pre-receive钩子（在gitlab企业版中叫做git钩子） 执行你请求的动作 处理gitlab的post-receive动作 处理自定义的post-receive动作 当通过http\\https访问gitlab server时，工作流程取决于你是从git仓库拉取(pull)代码还是向git仓库推送(push)代码 如果你是从git仓库拉取(pull)代码，gitlab rails应用会全权负责处理用户鉴权和执行git命令的工作 如果你是从git仓库推送(push)代码，gitlab rails应用既不会进行用户鉴权也不会执行git命令，它会把以下工作交由gitlab shell进行处理 调用gitlab rails api检查权限 执行pre-receive钩子（在gitlab企业版中叫做git钩子） 执行你请求的动作 处理gitlab的post-receive动作 处理自定义的post-receive动作 5.2 gitlab workhorse gitlab workhorse是一个敏捷的反向代理，它会处理一些大的http请求，比如文件的上传、文件的下载、git push/pull和git包下载。其它的请求会反向代理到gitlab rails应用，即反向代理给后端的unicorn 6. gitlab 命令 启动所有的gitlab组件 # gitlab-ctl start 停止所有gitlab组件 # gitlab-ctl stop 停止postgresql组件 # gitlab-ctl stop postgresql 停止相关的数据连接服务 # gitlab-ctl stop unicorn # gitlab-ctl stop sidekiq 重启所有gitlab组件 # gitlab-ctl restart 重启gitlab-workhorse组件 # gitlab-ctl restart gitlab-workhorse 查看服务状态 # gitlab-ctl status 如果更改了配置文件[gitlab.rb 文件]，使配置文件生效，但是会初始化除了gitlab.rb之外的所有文件 # sudo gitlab-ctl reconfigure 查看日志 # sudo gitlab-ctl tail 检查redis的日志 # sudo gitlab-ctl tail redis 7. gitlab主要目录 /var/opt/gitlab/git-data/repositories/ ：库默认存储的目录 /opt/gitlab/ ： 应用代码和相应的依赖程序存放目录 /var/opt/gitlab ： gitlab-ctl reconfigure命令编译后的应用数据和配置文件，不需要人为修改配置 /etc/gitlab ： 配置文件目录 /var/log/gitlab/ : 此目录下存放了各个组件产生的日志 /var/opt/gitlab/backups/ ： 备份文件生成的目录 gitlab关闭用户注册功能 登录web界面后 点击上方导航栏的Admin Area 点击左边的设置setting 找到Sign-up restrictions配置区域，点击扩展 去掉Sign-up enabled前面的√ 最后点击save保存按钮 8. gitlab 仓库管理 gitlab是通过组（group）的概念来统一管理仓库(project)和用户（user），通过创建组、在组下再创建仓库、再将用户加入到组，从而实现用户与仓库的权限管理 创建组 create group 在管理员页面顶部的Admin area按钮，进入管理员区域 点击new group按钮 填写必要的信息 组名、组路径、组描述 组可见级别 Visibility level ：选择谁可以访问该组、我们默认选择private即可 Private：The group and its projects can only be viewed by members. 只有授权的用户才可以看到 Internal：The group and any internal projects can be viewed by any logged in user. 只要是登录gitlab的用户都可以看到 Public：The group and any public projects can be viewed without any authentication. 只要是可以访问gitlab web页面的人都可以看到 信息填完、点击创建组 进入创建好的组管理界面 可以再找个界面下创建组用户的 9. 创建用户create user 在管理员页面点击页面顶部的Admin Area按钮，进入管理员区域 点击创建用户 填写必要的信息 用户名昵称、用户名、电子邮箱、选择用户级别 点击创建用户 进入用户的管理界面 点击页面的右上页的Edit按钮，为用户设置初始密码 也可以设置用户的其他信息 最后点击save更改 10. 用户授权（grant user） 用户创建完成后，我们就需要对用户进行授权，从而使用户可以管理仓库，有两种方式，一 是 将用户加入到组，这样用户可以管理组内的仓库；二是 直接授权用户管理仓库。通常我们采用的方式是将用户加入到相应的组，并赋予不同的角色。Gitlab中用户的角色是系统定义好的，不能更改，这一点可能不符合我们正常的思维习惯。 下面将刚创建好的nqt用户添加到xmlgrg_test组，并赋予developer的权限 在管理员区域、点击创建的组，进入组管理界面 选择用户、给予权限，点击添加 添加成功 相应权限的官方文档说明：https://docs.gitlab.com/ee/user/permissions.html 11. 创建仓库create project 在gitlab中，创建project用来存储你的程序代码、作为一个问题的跟踪器、用于代码协作、用于持续集成中的构建、测试和部署等服务。 在管理员区域点击New project 填写新建仓库的信息 创建完成后页面有这2个提示、先不要管 仓库的管理页面左侧为仓库操作的相关菜单栏、右侧空仓库下显示如何在命令行连接该仓库、非空时显示仓库内容 Command line instructions Git global setup # git config --global user.name \"Administrator\" # git config --global user.email \"admin@example.com\" Create a new repository # git clone http://192.168.137.100/xmlgrg_test/xm.git # cd xm # touch README.md # git add README.md # git commit -m \"add README\" # git push -u origin master Existing folder # cd existing_folder # git init # git remote add origin http://192.168.137.100/xmlgrg_test/xm.git # git add . # git commit -m \"Initial commit\" # git push -u origin master Existing Git repository # cd existing_repo # git remote rename origin old-origin # git remote add origin http://192.168.137.100/xmlgrg_test/xm.git # git push -u origin --all # git push -u origin --tags 将仓库加入到组后，组内的成员就可以看到该仓库 使用nqt用户登录。可以看到仓库xm 12. 配置ssh key 仓库是私有的，只有授权的用户才可以访问该仓库，那么只要客户端的用户与我们gitlab的用户绑定，客户端即可访问到gitlab上的仓库，建议使用ssh方式实现客户端与gitlab用户的绑定，具体配置如下： 在客户端生成ssh密钥对(注意 windows客户端下只能使用rsa加密方式) 在192.168.211.90 ，gitlab的服务器上 切换到运行gitlab的用户下，我这里直接使用的是服务器的root用户 # ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:TPquDQ/XGM5zBefa86ZCfKiGLh8aWHWbbVEdV06etUM root@localhost.localdomain The key's randomart image is: +---[RSA 2048]----+ | ...E*| | . o=+| | . o o . +o| | . = + = .| | . . S.o.o | | o + =++. | | . . +.Bo+.o | | .o.Ooo. o. | | .++o+ ..o. | +----[SHA256]-----+ # ll /root/.ssh/ 总用量 8 -rw------- 1 root root 1679 5月 2 17:07 id_rsa -rw-r--r-- 1 root root 408 5月 2 17:07 id_rsa.pub # cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDC9rQr5/sh7EJGMmScIJnyG+vWaXpjibA4i81ik14pdyeV80CYTmV7h38fYSKbsGI+MeQX8euvsqveGhNqJsNvTSNm/c5aoHudY6vNrvVkP1SM1gIsdgGb8I2uJeQBPi KftLnWashuO85vKiZ5hmv9THMW/Zn1NhiCuh3Ixj2PqEiUGxLLMb4NltJSoJOrOkKYZKd6FyLqXoLNJ9QN/m8uCHgS2vlTa7wvNIOZwAQnZ3Rx95dSusosUDHzfwBeMkCuNQpcP2kkQ2E6r+oi+zAlW/q6sUhHQzg0t1zat8IgEpJi3cu0TJRrdAnjNLlSL4Ue+RpmRrwoKs/gUgmrdIlZ root@localhost.localdomain 将该用户与gitlab的root用户绑定 点击gitlab用户的图标、找到setting 进入到用户的设置页面、点击左侧菜单栏的ssh keys 这个页面还可以设置用户的其它信息 Ssh的配置页面 此处只能添加公钥，注意、一个公钥在整个gitlab系统中只能添加一次，但是一个gitlab用户可以添加多个公钥 13. 推送本地客户端仓库到gitlab yum install -y git git --version 设置本仓库的global级别信息 # git config --global user.name quntao # git config --global user.email xmlgrg@163.com # git config --list user.name=quntao user.email=xmlgrg@163.com 创建一个空仓库 # pwd /data/git_test # git init 初始化空的 Git 版本库于 /data/git_test/.git/ # ll -a 总用量 0 drwxr-xr-x 3 root root 18 5月 2 20:09 . drwxr-xr-x 3 root root 22 5月 2 20:09 .. drwxr-xr-x 7 root root 119 5月 2 20:09 .git 设置过滤文件 有了仓库，我们便可以在git_test文件夹下的工作区做文件的增删修改工作了，但很多时候，我们只在意开发过程中的源文件，并不需要管理自动产生的其它临时文件。这时候便需要一个过滤文件，在这个文件中设置过滤规则，让git能够自动过滤掉那些临时文件，这个文件便是.gitignore文件。 在仓库目录下创建.gitignore文件 # pwd /data/git_test # touch .gitignore # vim .gitignore # cat .gitignore test.txt /test/ *.txt test.txt //过滤test.txt文件 /test/ //过滤test目录 *.txt //过滤所有以.txt结尾的文件 常用的通配规则： 以斜杠“/”开头表示目录 以星号“*”通配说个字符 以问号“？”通配单个字符 以方括号”[]“包含单个字符的匹配列表 以叹号“！”表示不忽略(跟踪)匹配到的文件或目录 # touch a # touch b # touch c # git add a # git add b # git add c # git commit -m \"commit a\" //\"commit a\" 提交版本的描述信息 [master（根提交） 4141cd7] commit a 3 files changed, 0 insertions(+), 0 deletions(-) create mode 100644 a create mode 100644 b create mode 100644 c 推送本地客户端仓库到gitlab中 # pwd /data/git_test # git remote add gitlab git@192.168.137.100:xmlgrg_test/xm.git 您在 /var/spool/mail/root 中有新邮件 # git remote gitlab # ll -a 总用量 4 drwxr-xr-x 3 root root 63 5月 2 20:19 . drwxr-xr-x 3 root root 22 5月 2 20:09 .. -rw-r--r-- 1 root root 0 5月 2 20:19 a -rw-r--r-- 1 root root 0 5月 2 20:19 b -rw-r--r-- 1 root root 0 5月 2 20:19 c drwxr-xr-x 8 root root 166 5月 2 20:25 .git -rw-r--r-- 1 root root 22 5月 2 20:14 .gitignore # git push -u gitlab master The authenticity of host '192.168.137.100 (192.168.137.100)' can't be established. ECDSA key fingerprint is SHA256:zUU81Kb1Q5uS1ewufeZ1qLyErPI0uOyIhEmOabssXoE. ECDSA key fingerprint is MD5:1a:bc:a7:24:e7:f6:ce:4e:d3:df:56:ac:4a:e2:a5:3c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.137.100' (ECDSA) to the list of known hosts. Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 203 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@192.168.137.100:xmlgrg_test/xm.git * [new branch] master -> master 分支 master 设置为跟踪来自 gitlab 的远程分支 master。 提示推送成功，我们在gitlab上的xm仓库上可以看到推送上来的内容 14. 克隆gitlab仓库到本地客户端 192.168.211.91 在这台服务器上安装git 使用yum默认安装的git版本是1.8，版本较低，我们可以使用源码安装 首先需要安装依赖库： # yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker 下载最新的源码包 # cd /usr/local/src/ # wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.2.tar.xz # tar xf git-2.19.2.tar.xz # cd git-2.19.2 # make prefix=/usr/local/git all # make prefix=/usr/local/git install # rm -rf /usr/bin/git # ln -s /usr/local/git/bin/git /usr/bin/git # git --version git version 2.19.2 生成ssh key [root@localhost git-2.19.2]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: SHA256:deiQnPXeqNII+GsnVedBO0255UWtGto4PEbeEYSBTPo root@localhost.localdomain The key's randomart image is: +---[RSA 2048]----+ | o..o+. oo| | oo+.oo o +| | . = o.o= =.| | . . +ooBo+ .| | . . E=.Bo*. | | . ..oO.= | | ..o.oo | | o... | | ..o | +----[SHA256]-----+ [root@localhost git-2.19.2]# ll /root/.ssh/ 总用量 8 -rw------- 1 root root 1675 5月 2 20:44 id_rsa -rw-r--r-- 1 root root 408 5月 2 20:44 id_rsa.pub [root@localhost git-2.19.2]# cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCwUIYoYKPxp23ZH+Q4DmQJtuxv9AWmZUKemTVJ0cBDB03K4AhF64orfODrdGmEr1G0IllPuhMJ7HtbRR7EcsCE8MunxikRyJhb8iOYzTtTkGDy9Q0aZ/BUKx7wAmIj+u NHe+X8YUYtpMfMngtLl5XL0yHRvMoPVaUPT9FlejfRtrj3Qh8+vKiN4q9c36tC8eoyEnKE656yboTNkYE43Djp6DyynPmNcuB4dOVNz+OA+uR7OIidT6fxw16bxkCXUQeQ/Y6doMCOjBuZEUsD0VaSQ5J16ewd47cBbeEv/fVUIoZFXv5VrtowYWU6WlzMu2AQRiQs+ZeYik0L2UqcOXmP root@localhost.localdomain 然后配置192.168.211.91客户端与gitlab上的nqt用户绑定 使用git clone命令克隆仓库到192.168.211.91服务器本地 [root@localhost data]# mkdir /101 [root@localhost data]# cd /101 [root@localhost 101]# git clone git@192.168.137.100:xmlgrg_test/xm.git 正克隆到 'xm'... The authenticity of host '192.168.137.100 (192.168.137.100)' can't be established. ECDSA key fingerprint is SHA256:zUU81Kb1Q5uS1ewufeZ1qLyErPI0uOyIhEmOabssXoE. ECDSA key fingerprint is MD5:1a:bc:a7:24:e7:f6:ce:4e:d3:df:56:ac:4a:e2:a5:3c. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '192.168.137.100' (ECDSA) to the list of known hosts. remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0) 接收对象中: 100% (3/3), 完成. [root@localhost 101]# ll -a 总用量 0 drwxr-xr-x 3 root root 16 5月 2 20:49 . dr-xr-xr-x. 19 root root 247 5月 2 20:49 .. drwxr-xr-x 3 root root 45 5月 2 20:49 xm [root@localhost 101]# cd xm [root@localhost xm]# ll -a 总用量 0 drwxr-xr-x 3 root root 45 5月 2 20:49 . drwxr-xr-x 3 root root 16 5月 2 20:49 .. -rw-r--r-- 1 root root 0 5月 2 20:49 a -rw-r--r-- 1 root root 0 5月 2 20:49 b -rw-r--r-- 1 root root 0 5月 2 20:49 c drwxr-xr-x 8 root root 163 5月 2 20:49 .git [root@localhost xm]# [root@localhost xm]# git remote origin 可以看到已经将gitlab上的xm仓库克隆到192.168.137.101本地，同时为本地仓库添加了一个指向gitlab上xm仓库的远程仓库 在192.168.137.101的xm上创建一个dev的分支，并将dev分支，推送到gitlab上 [root@localhost 101]# cd xm [root@localhost xm]# pwd /101/xm [root@localhost xm]# pwd /101/xm [root@localhost xm]# git checkout -b dev 切换到一个新分支 'dev' [root@localhost xm]# git status 位于分支 dev 无文件要提交，干净的工作区 [root@localhost xm]# git push -u origin dev 总共 0 （差异 0），复用 0 （差异 0） remote: remote: To create a merge request for dev, visit: remote: http://192.168.137.100/xmlgrg_test/xm/merge_requests/new?merge_request%5Bsource_branch%5D=dev remote: To 192.168.137.100:xmlgrg_test/xm.git * [new branch] dev -> dev 分支 'dev' 设置为跟踪来自 'origin' 的远程分支 'dev'。 完成后，在gitlab上可以看到推上来的dev分支 15. 设置分支保护 在实际使用过程中，通常会保持master分支的稳定，用于生产环境的版本发布，只有授权的用户才可以向master合并代码。要实现此功能，需要将master设置为保护分支，同时授权什么用户可以向master用户推送代码。 使用root用户登录gitlab，点击xm仓库页面左下角的setting 进入设置页面，选择设置菜单栏下面的Repository选项 找到Protected Branches、点击展开 展开Protected Branches 设置完dev为保护的后，在仓库的分支页面，可看到分支后出现一个绿色的protected 默认的情况下，master分支是不允许developer角色向其推送内容的 16. Gitlab的备份、恢复、升级 对gitlab进行备份将会创建一个包含所有库和附件的归档文件，对备份的恢复只能恢复到与备份时的gitlab相同的版本。将gitlab迁移到另一台服务器上的最佳方法就是通过备份和还原。Gitlab提供了一个简单的命令行来备份整个gitlab，并且能灵活的满足需求。 备份配置 备份文件将保存在配置文件中定义的backup_path中，文件名为TIMESTAMP_GITLAB_BACKUP.TAR，TIMESTAMP为备份的时间戳。TIMESTAMP的格式为：EPOCH_YYYY_MM_DD_Gitlab-version。 默认的备份文件目录为：/var/opt/gitlab/backups，如果自定义备份目录需要赋予目录git权限，具体操作如下： 配置文件中加入： # vim /etc/gitlab/gitlab.rb ### Backup Settings ###! Docs: https://docs.gitlab.com/omnibus/settings/backups.html #gitlab_rails['manage_backup_path'] = true gitlab_rails['backup_path'] = \"/data/gitlab/backups\" #备份的目录 ##!Docs:https://docs.gitlab.com/ce/raketasks/backup_restore.html#backup-archive-permissions # gitlab_rails['backup_archive_permissions'] = 0644 # gitlab_rails['backup_pg_schema'] = 'public' ###! The duration in seconds to keep backups before they are allowed to be deleted gitlab_rails['backup_keep_time'] = 604800 #备份保留的时间(以秒为单位，这个是7天默认值) 在命令行执行命令如下 # mkdir -pv /data/gitlab/backups # chown -R git.git /data/gitlab/backups/ # gitlab-ctl reconfigure # gitlab-ctl restart 16.1 手动备份 在命令行执行： # gitlab-rake gitlab:backup:create 2019-05-18 21:26:25 +0800 -- Dumping database ... Dumping PostgreSQL database gitlabhq_production ... [DONE] 2019-05-18 21:26:25 +0800 -- done 2019-05-18 21:26:25 +0800 -- Dumping repositories ... * xmlgrg_test/xm ... [DONE] [SKIPPED] Wiki 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping uploads ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping builds ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping artifacts ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping pages ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping lfs objects ... 2019-05-18 21:26:26 +0800 -- done 2019-05-18 21:26:26 +0800 -- Dumping container registry images ... 2019-05-18 21:26:26 +0800 -- [DISABLED] Creating backup archive: 1558185986_2019_05_18_11.9.1_gitlab_backup.tar ... done Uploading backup archive to remote storage ... skipped Deleting tmp directories ... done done done done done done done done Deleting old backups ... done. (0 removed) # ll /data/gitlab/backups/ 在制定的目录下生成对应的备份文件 总用量 112 -rw------- 1 git git 112640 5月 18 21:26 1558185986_2019_05_18_11.9.1_gitlab_backup.tar 16.2 定时备份 通过在定时任务里添加： 每天凌晨2点进行一次自动备份:通过crontab使用备份命令实现，需重启cron服务 输入命令crontab -e sudo crontab -e #输入相应的任务 环境变量CRON=1的作用是如果没有任何错误发生时，抑制备份脚本的所有进度输出 0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create CRON=1 # systemctl restart crond 重启服务 在crontab文件里面，每一行代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，每个字段之间用空格分割，没用的段用*代替，格式如下： m h dom mon dow user command 其中： m： 表示分钟，可以是从0到59之间的任何整数。 h：表示小时，可以是从0到23之间的任何整数。 dom：表示日期，可以是从1到31之间的任何整数。 mon：表示月份，可以是从1到12之间的任何整数。 dow：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 user : 表示执行的用户。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件(如shell文件)。 16.3 恢复实践 Gitlab的恢复只能还原到与备份文件相同的gitlab版本的系统中，恢复时，停止连接到数据库的进程(也就是停止数据的写入服务)，但是保持gitlab是运行的。 # gitlab-ctl stop unicorn ok: down: unicorn: 1s, normally up # gitlab-ctl stop sideki # gitlab-ctl status run: alertmanager: (pid 11282) 1356s; run: log: (pid 1872) 5129s run: gitaly: (pid 11298) 1355s; run: log: (pid 1859) 5129s run: gitlab-monitor: (pid 11338) 1355s; run: log: (pid 1865) 5129s run: gitlab-workhorse: (pid 11376) 1354s; run: log: (pid 1861) 5129s run: logrotate: (pid 11387) 1354s; run: log: (pid 1860) 5129s run: nginx: (pid 11397) 1353s; run: log: (pid 1852) 5129s run: node-exporter: (pid 11407) 1353s; run: log: (pid 1862) 5129s run: postgres-exporter: (pid 11508) 1352s; run: log: (pid 1869) 5129s run: postgresql: (pid 11524) 1351s; run: log: (pid 1847) 5129s run: prometheus: (pid 11540) 1350s; run: log: (pid 1877) 5129s run: redis: (pid 11559) 1349s; run: log: (pid 1875) 5129s run: redis-exporter: (pid 11598) 1349s; run: log: (pid 1870) 5129s run: sidekiq: (pid 11609) 1346s; run: log: (pid 1878) 5129s down: unicorn: 29s, normally up; run: log: (pid 1876) 5129s # 执行恢复操作 # gitlab-rake gitlab:backup:restore 整个恢复执行过程中，可以看到基本是在删除表，创建表 2处需要输入yes Before restoring the database, we will remove all existing tables to avoid future upgrade problems. Be aware that if you have custom tables in the GitLab database these tables and all data will be removed. Do you want to continue (yes/no)? yes This task will now rebuild the authorized_keys file. You will lose any data stored in the authorized_keys file. Do you want to continue (yes/no)? yes Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-13 04:50:55 "},"Gitlab/2_Gitlab_Install.html":{"url":"Gitlab/2_Gitlab_Install.html","title":"2 Gitlab Install","keywords":"","body":"Gitlab 安装1. 简介2. 准备3. 部署3.1 docker安装GitLab-ce配置存储位置3.2 Docker-compose安装gitlab4. 配置4.1 获取密码4.2 修改密码Gitlab 安装 1. 简介 Gitlab是一个开源的Git代码仓库系统，可以实现自托管的Github项目，即用于构建私有的代码托管平台和项目管理系统。系统基于Ruby on Rails开发，速度快、安全稳定。它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 2. 准备 install docker in ubuntu 卸载旧版本 sudo apt-get remove docker docker-engine docker.io containerd runc rm -rf /var/lib/docker/ 配置docker源 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release #下载gpg证书 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg #其他版本 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 安装docker #查看版本 apt-cache madison docker-ce sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 或者指定特定版本 sudo apt-get install docker-ce= docker-ce-cli= containerd.io 3. 部署 3.1 docker安装GitLab-ce GitLab的安装可以直接run，或者通过docker-compose文件指定安装流程，这里使用前者进行快速简单安装，后者后续更新。 拉取GitLab-ce镜像，查看镜像信息 $ docker pull gitlab/gitlab-ce $ docker image ls 配置存储位置 $ mkdir /opt/gitlab $ export GITLAB_HOME=/opt/gitlab $ echo $GITLAB_HOME /opt/gitlab 运行gitlab $ docker run -d --hostname gitlab.example.com -p 443:443 -p 80:80 -p 22:22 --name gitlab --restart always -v $GITLAB_HOME/config:/etc/gitlab:Z -v $GITLAB_HOME/logs:/var/log/gitlab:Z -v $GITLAB_HOME/data:/var/opt/gitlab:Z --shm-size 256m gitlab/gitlab-ce:latest :Z能够确保有足够的权限的权限创建文件 正常要等1~2分钟。 假如报错 bash /opt/gitlab/embedded/bin/runsvdir-start: line 24: ulimit: pending signals: cannot modify limit: Operation not permitted /opt/gitlab/embedded/bin/runsvdir-start: line 37: /proc/sys/fs/file-max: Read-only file system Configuring GitLab package... Configuring GitLab... 解决方法： chmod 2770 /opt/gitlab/data/git-data/repositories docker restart gitlab 查看容器运行情况，出现gitlab运行信息表明启动成功 $ docker ps 浏览器进入http://192.168.211.70:8080，使用root账户登录并设置密码即可进入管理员界面 环境变量GITLAB_OMNIBUS_CONFIG添加到Docker run来预先配置GitLab Docker镜像。这个变量包含任何gitlab.rb设置,，GITLAB_OMNIBUS_CONFIG中包含的设置不写入gitlab.rb配置文件。 下面是一个设置外部URL并在启动容器时启用LFS的例子: docker run --detach \\ --hostname gitlab.example.com \\ --env GITLAB_OMNIBUS_CONFIG=\"external_url 'http://my.domain.com/'; gitlab_rails['lfs_enabled'] = true;\" \\ --publish 443:443 --publish 80:80 --publish 22:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ --shm-size 256m \\ gitlab/gitlab-ee:latest 使用不同的端口 如果你想使用一个不同于80 (HTTP)或443 (HTTPS)的主机端口，你需要添加一个单独的——publish指令到docker运行命令。 $ docker run --detach \\ --hostname gitlab.example.com \\ --publish 8929:8929 --publish 2289:22 \\ --name gitlab \\ --restart always \\ --volume $GITLAB_HOME/config:/etc/gitlab \\ --volume $GITLAB_HOME/logs:/var/log/gitlab \\ --volume $GITLAB_HOME/data:/var/opt/gitlab \\ --shm-size 256m \\ gitlab/gitlab-ee:latest $ docker exec -it gitlab /bin/bash $ vi /etc/gitlab/gitlab.rb # For HTTP external_url \"http://gitlab.example.com:8929\" or # For HTTPS (notice the https) external_url \"https://gitlab.example.com:8929\" gitlab_rails['gitlab_shell_ssh_port'] = 2289 $ gitlab-ctl reconfigure 端映射格式为“hostPort:containerPort”。更多信息请参阅Docker的文档 此external_url中指定的端口必须与Docker发布给主机的端口相匹配。此外，如果NGINX监听端口没有在NGINX ['listen_port']中显式设置，它将从external_url中拉出。要了解更多信息，请参阅NGINX文档。 3.2 Docker-compose安装gitlab 使用Docker Compose，你可以轻松地配置、安装和升级基于Docker的GitLab安装: 安装docker-compose 编排docker-compose.yml version: '3.6' services: web: image: 'gitlab/gitlab-ee:latest' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'https://gitlab.example.com' # Add any other gitlab.rb configuration here, each on its own line ports: - '80:80' - '443:443' - '22:22' volumes: - '$GITLAB_HOME/config:/etc/gitlab' - '$GITLAB_HOME/logs:/var/log/gitlab' - '$GITLAB_HOME/data:/var/opt/gitlab' shm_size: '256m' docker-compose up -d 如果我们自定义HTTP和SSH端口。需要定义GITLAB_OMNIBUS_CONFIG变量是如何匹配端口部分的: version: '3.6' services: web: image: 'gitlab/gitlab-ee:latest' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.example.com:8929' gitlab_rails['gitlab_shell_ssh_port'] = 2224 ports: - '8929:8929' - '2224:22' volumes: - '$GITLAB_HOME/config:/etc/gitlab' - '$GITLAB_HOME/logs:/var/log/gitlab' - '$GITLAB_HOME/data:/var/opt/gitlab' shm_size: '256m' 4. 配置 4.1 获取密码 $ cat /etc/gitlab/initial_root_password # WARNING: This value is valid only in the following conditions # 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails['initial_root_password']` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run). # 2. Password hasn't been changed manually, either via UI or via command line. # # If the password shown here doesn't work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password. Password: mmPPA7vlzRPgdEgQXu1LnWbok6OUNgiAgoZvhYnCgrw= # NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours. mmPPA7vlzRPgdEgQXu1LnWbok6OUNgiAgoZvhYnCgrw=是默认的初始密码， 我们可以在/etc/gitlab/gitlab.rb配置文件中设置自己的root密码，也可以用默认的密码登陆再修改自己想要的密码。要注意该文件24小时后自动删除。 4.2 修改密码 修改重新登陆即可。 参考官方部署 Create a Continuous Integration (CI) Pipeline in Gitlab gitlab-runner部署 git 本地项目上传github或gitlab详解 git与gitlab快速学习手册 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitlab/3_gitlab_config.html":{"url":"Gitlab/3_gitlab_config.html","title":"3 Gitlab Config","keywords":"","body":"gitlab 配置1. 邮箱发送短信2. 注册账号3. 创建项目3.1 创建空白项目3.2 创建模板项目3.3 导入项目4. 删除项目5. gitlab项目上传githubgitlab 配置 相关阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 1. 邮箱发送短信 $ docker exec -ti gitlab bash $ vi /etc/gitlab/gitlab.rb gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = \"smtp-mail.outlook.com\" gitlab_rails['smtp_port'] = 25 gitlab_rails['smtp_user_name'] = \"@outlook.com\" gitlab_rails['smtp_password'] = \"\" gitlab_rails['smtp_domain'] = \"outlook.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = false gitlab_rails['gitlab_email_enabled'] = true gitlab_rails['gitlab_email_from'] = '@outlook.com' gitlab_rails['gitlab_email_display_name'] = 'Gitlab' 保存退出修改，执行命令gitlab-ctl reconfigure重新配置gitlab $ gitlab-ctl reconfigure 执行命令gitlab-ctl console测试发邮件，进入控制台之后执行命令 Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now irb(main):001:0> Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now Delivered mail 61b9f42db6726_4fc5a503772f@gitlab.example.com.mail (3732.4ms) => #, >, >, , >, , , , , , > 2. 注册账号 填写自己的名字、邮箱、密码 注册后等待管理员验证通过。 登陆管理员，找到Admin 找到管理user的界面 发现新注册的用户 点击通过或拒绝。 通过后，你也可以对此用户进行限制访问或删除。 通过后，租户登陆，选择用户角色 创建项目或寻找项目 与管理员界面的区别缺少admin的权限 回到管理员的user用户管理界面，发现xiaoming已经被激活。 3. 创建项目 第一种 第二种 第三种 三类项目 空白项目，导入项目，模板项目 3.1 创建空白项目 当我们在点击创建之前，如果点击了“README”，如下 那创建出来的项目是这样的。 3.2 创建模板项目 当我们选择模板项目时，会有需要各类开发的模板项目供我们选择。 这个关于kubernets的gitbook项目 我们可以编写自己的gitbook了。 3.3 导入项目 导入项目，适合以下场景： 项目迁移 借用开源项目定制开发 我们需要一个token,这个token来自于你选择的平台，而不是来自自己的gitlab平台，我这选择了github平台。 我们现在去创建token，我们 登陆github，选择设置“setting” 找到“developer settings” 根据兴趣随便取 我们创建出来了 复制到gitlab的这里 获取到我的github账号下的项目列表，选择其中一个 开始导入 导入完成。 查看gitlab导入的项目 查看项目内容，然后根据自己的需求开发属于你自己的项目吧。 4. 删除项目 我们要删除这个项目 再次确认 我们找不到了gitlab-example-demo了 5. gitlab项目上传github github创建一个空项目 $ git clone http://gitlab.example.com:8081/root/gitlab-example-demo.git $ cd gitlab-example-demo $ git remote -v origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git remote add hello https://github.com/Ghostwritten/gitlab-example-demo.git root@yourdomain:/data/gitlab/projects/gitlab-example-demo# git remote -v hello https://github.com/Ghostwritten/gitlab-example-demo.git (fetch) hello https://github.com/Ghostwritten/gitlab-example-demo.git (push) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git push -u hello Username for 'https://github.com': ghostwritten Password for 'https://ghostwritten@github.com': Counting objects: 24, done. Delta compression using up to 4 threads. Compressing objects: 100% (22/22), done. Writing objects: 100% (24/24), 2.36 KiB | 201.00 KiB/s, done. Total 24 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), done. To https://github.com/Ghostwritten/gitlab-example-demo.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'hello'. Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitlab/4_Gitlab_Runner_Install.html":{"url":"Gitlab/4_Gitlab_Runner_Install.html","title":"4 Gitlab Runner Install","keywords":"","body":"Gitlab Runner 部署1. 本地安装gitlab-runner2. 项目通过本地命令注册runner3. docker安装gitlab-runner4. 项目通过docker注册runner5. 注意Gitlab Runner 部署 1. 本地安装gitlab-runner $ wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 $ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash $ yum install gitlab-runner $ systemctl status gitlab-runner $ sudo chown -R gitlab-runner:gitlab-runner /var/run/docker.sock $ sudo su - gitlab-runner 当然，我们可以安装官方的方法安装，从gitlab就可以找到简洁的安装方式： 2. 项目通过本地命令注册runner 1 输入如下命令 $ sudo gitlab-runner register 2 输入gitlab地址 地址可以从项目中获取到 这个页面会获取到地址和token，下面用到 3 输入token，就是截图里的token 4 输入对Runner的描述，这个在GitLab’s UI可以修改，比如my-runner 5 给Runner打个标签，这个在GitLab’s UI可以修改，比如java 6 是否Runner执行没有标签的构建任务，输入true 7 是否将Runner锁定到当前项目，这个在GitLab’s UI可以修改，输入true 8 输入Runner的执行者，这里我选择shell 这样我们就配置好了Runner 当我们有代码提交的时候，Runner就会执行.gitlab-ci.yml的构建任务 3. docker安装gitlab-runner docker run -d --name gitlab-runner --restart always --net=host \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 您可以使用配置容器来挂载您的自定义数据卷 docker volume create gitlab-runner-config docker run -d --name gitlab-runner --restart always --net=host \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v gitlab-runner-config:/etc/gitlab-runner \\ gitlab/gitlab-runner:latest 4. 项目通过docker注册runner $ docker run --rm --net=host -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=7 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://192.168.211.70:8081 Enter the registration token: 6D5mo8iWCLBaVdqcaqjN Enter a description for the runner: [329b671ffa00]: gitlab-example Enter tags for the runner (comma-separated): Registering runner... succeeded runner=6D5mo8iW Enter an executor: ssh, virtualbox, docker+machine, shell, docker-ssh+machine, kubernetes, custom, docker, docker-ssh, parallels: docker Enter the default Docker image (for example, ruby:2.6): ubuntu:20.04 Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 我们选择的执行器是docker，那么关于这个项目，编写.gitlab-ci.yml就要一定docker执行的规则去执行。 注册配置内容我可以在这里看到。并根据需求做一些小的变动。 $ docker exec -ti gitlab-runner bash $ cat /etc/gitlab-runner/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" #这里的token，并不是registration token的token。 executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] tls_verify = false image = \"ubuntu:20.04\" privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] shm_size = 0 dns = [\"8.8.8.8\", \"1.1.1.1\"] 执行器选择是多种样的，我们当然也可以多个选择。通过多次注册的方式。 我尝试再次注册一次。 docker run --net=host --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=11 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://gitlab.example.com:8081 Enter the registration token: 6D5mo8iWCLBaVdqcaqjN Enter a description for the runner: [yourdomain.com]: gitlab-demo Enter tags for the runner (comma-separated): gitlab-demo-shell Registering runner... succeeded runner=6D5mo8iW Enter an executor: docker, docker-ssh, shell, docker+machine, custom, parallels, ssh, virtualbox, docker-ssh+machine, kubernetes: shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 这次的执行器是shell。 登陆gitlab查看runner的列表，多出一个runner 查看runner配置 $ docker exec -ti gitlab-runner bash $ cat /etc/gitlab-runner/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"\" url = \"\" token = \"\" executor = \"\" [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] tls_verify = false image = \"ubuntu:20.04\" dns = [\"8.8.8.8\", \"1.1.1.1\"] privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] shm_size = 0 [[runners]] name = \"gitlab-demo\" url = \"http://gitlab.example.com:8081\" token = \"TX1s_ZQ1RnNj5xaVW-y9\" executor = \"shell\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 关于一个项目我们通过多次注册编排，选择不同执行器编排.gitlab-ci.yml,比如，你可能需要这个应用暂时本地运行，后来docker运行，再后来kubernets运行等等。 5. 注意 不同的项目向runner注册的token是不一样的。 我们可以在根据自己的业务应用需求在多个机器运行多个gitlab-runner。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Gitlab/5_Gitlab_Runner_Management.html":{"url":"Gitlab/5_Gitlab_Runner_Management.html","title":"5 Gitlab Runner Management","keywords":"","body":"Gitlab 基础配置1. 邮箱发送短信2. 注册账号3. 创建项目3.1 创建空白项目3.2 创建模板项目3.3 导入项目4. 删除项目5. gitlab项目上传githubGitlab 基础配置 1. 邮箱发送短信 $ docker exec -ti gitlab bash $ vi /etc/gitlab/gitlab.rb gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = \"smtp-mail.outlook.com\" gitlab_rails['smtp_port'] = 25 gitlab_rails['smtp_user_name'] = \"@outlook.com\" gitlab_rails['smtp_password'] = \"\" gitlab_rails['smtp_domain'] = \"outlook.com\" gitlab_rails['smtp_authentication'] = \"login\" gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = false gitlab_rails['gitlab_email_enabled'] = true gitlab_rails['gitlab_email_from'] = '@outlook.com' gitlab_rails['gitlab_email_display_name'] = 'Gitlab' 保存退出修改，执行命令gitlab-ctl reconfigure重新配置gitlab $ gitlab-ctl reconfigure 执行命令gitlab-ctl console测试发邮件，进入控制台之后执行命令 Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now irb(main):001:0> Notify.test_email('@139.com', '邮件标题', '邮件正文').deliver_now Delivered mail 61b9f42db6726_4fc5a503772f@gitlab.example.com.mail (3732.4ms) => #, >, >, , >, , , , , , > 2. 注册账号 填写自己的名字、邮箱、密码 注册后等待管理员验证通过。 登陆管理员，找到Admin 找到管理user的界面 发现新注册的用户 点击通过或拒绝。 通过后，你也可以对此用户进行限制访问或删除。 通过后，租户登陆，选择用户角色 创建项目或寻找项目 与管理员界面的区别缺少admin的权限 回到管理员的user用户管理界面，发现xiaoming已经被激活。 3. 创建项目 第一种 第二种 第三种 三类项目 空白项目，导入项目，模板项目 3.1 创建空白项目 当我们在点击创建之前，如果点击了“README”，如下 那创建出来的项目是这样的。 3.2 创建模板项目 当我们选择模板项目时，会有需要各类开发的模板项目供我们选择。 这个关于kubernets的gitbook项目 我们可以编写自己的gitbook了。 3.3 导入项目 导入项目，适合以下场景： 项目迁移 借用开源项目定制开发 我们需要一个token,这个token来自于你选择的平台，而不是来自自己的gitlab平台，我这选择了github平台。 我们现在去创建token，我们 登陆github，选择设置“setting” 找到“developer settings” 根据兴趣随便取 我们创建出来了 复制到gitlab的这里 获取到我的github账号下的项目列表，选择其中一个 开始导入 导入完成。 查看gitlab导入的项目 查看项目内容，然后根据自己的需求开发属于你自己的项目吧。 4. 删除项目 我们要删除这个项目 再次确认 我们找不到了gitlab-example-demo了 5. gitlab项目上传github github创建一个空项目 $ git clone http://gitlab.example.com:8081/root/gitlab-example-demo.git $ cd gitlab-example-demo $ git remote -v origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git remote add hello https://github.com/Ghostwritten/gitlab-example-demo.git root@yourdomain:/data/gitlab/projects/gitlab-example-demo# git remote -v hello https://github.com/Ghostwritten/gitlab-example-demo.git (fetch) hello https://github.com/Ghostwritten/gitlab-example-demo.git (push) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (fetch) origin http://gitlab.example.com:8081/root/gitlab-example-demo.git (push) $ git push -u hello Username for 'https://github.com': ghostwritten Password for 'https://ghostwritten@github.com': Counting objects: 24, done. Delta compression using up to 4 threads. Compressing objects: 100% (22/22), done. Writing objects: 100% (24/24), 2.36 KiB | 201.00 KiB/s, done. Total 24 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), done. To https://github.com/Ghostwritten/gitlab-example-demo.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'hello'. 相关阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-13 04:51:13 "},"Gitlab/6_Gitlab_Create_CI_Pipeline.html":{"url":"Gitlab/6_Gitlab_Create_CI_Pipeline.html","title":"6 Gitlab Create CI Pipeline","keywords":"","body":"Gitlab 创建持续集成 (CI) Pipeline1.简介2.CI demo2.1 python demo2.2 部署gitlab2.3 项目上传gitlab2.4 编排.gitlab-ci.yaml2.5. 部署gitlab-runner2.6 测试跑起来2.7 CI变得更安全Gitlab 创建持续集成 (CI) Pipeline 1.简介 2.CI demo 2.1 python demo vscode创建一下目录和文件 内容： test_functions.py from app.functions import sum def test_sum(): assert add(1, 10) == 11 functions.py def add(a, b): return a + b 安装测试工具 $ pip3 install pipenv Installing collected packages: virtualenv WARNING: Failed to write executable - trying to use .deleteme logic ERROR: Could not install packages due to an OSError: [WinError 2] 系统找不到指定的文件。: 'C:\\\\Python310\\\\Scripts\\\\virtualenv.exe' -> 'C:\\\\Python310\\\\Scripts\\\\virtualenv.exe.deleteme' #尝试 pip3 install pipenv --user Requirement already satisfied: pipenv in c:\\python310\\lib\\site-packages (2021.11.23) Requirement already satisfied: setuptools>=36.2.1 in c:\\python310\\lib\\site-packages (from pipenv) (57.4.0) Requirement already satisfied: pip>=18.0 in c:\\users\\xh\\appdata\\roaming\\python\\python310\\site-packages (from pipenv) (21.3.1) Requirement already satisfied: virtualenv-clone>=0.2.5 in c:\\python310\\lib\\site-packages (from pipenv) (0.5.7) Requirement already satisfied: certifi in c:\\users\\xh\\appdata\\roaming\\python\\python310\\site-packages (from pipenv) (2021.10.8) Requirement already satisfied: virtualenv in c:\\python310\\lib\\site-packages (from pipenv) (20.10.0) Requirement already satisfied: six=1.9.0 in c:\\python310\\lib\\site-packages (from virtualenv->pipenv) (1.16.0) Requirement already satisfied: distlib=0.3.1 in c:\\python310\\lib\\site-packages (from virtualenv->pipenv) (0.3.4) Requirement already satisfied: backports.entry-points-selectable>=1.0.4 in c:\\python310\\lib\\site-packages (from virtualenv->pipenv) (1.1.1) Requirement already satisfied: filelock=3.2 in c:\\python310\\lib\\site-packages (from virtualenv->pipenv) (3.4.0) Requirement already satisfied: platformdirs=2 in c:\\python310\\lib\\site-packages (from virtualenv->pipenv) (2.4.0) $ pipenv bash: pipenv: command not found #尝试 $ python -m pipenv #安装pytest $ python -m pipenv install pytest Creating a virtualenv for this project... Pipfile: D:\\gitlab\\Pipfile Using C:/Python310/python.exe (3.10.0) to create virtualenv... [ =] Creating virtual environment...created virtual environment CPython3.10.0.final.0-64 in 6580ms creator CPython3Windows(dest=C:\\Users\\XH\\.virtualenvs\\gitlab-DBb610So, clear=False, no_vcs_ignore=False, global=False) seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\XH\\AppData\\Local\\pypa\\virtualenv) added seed packages: pip==21.3.1, setuptools==58.3.0, wheel==0.37.0 activators BashActivator,BatchActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator Successfully created virtual environment! Virtualenv location: C:\\Users\\XH\\.virtualenvs\\gitlab-DBb610So Creating a Pipfile for this project... Installing pytest... Adding pytest to Pipfile's [packages]... Installation Succeeded Pipfile.lock not found, creating... Locking [dev-packages] dependencies... Locking [packages] dependencies... Building requirements... Resolving dependencies... Success! Updated Pipfile.lock (99a583)! Installing dependencies from Pipfile.lock (99a583)... ================================ 0/0 - 00:00:00 To activate this project's virtualenv, run pipenv shell. Alternatively, run a command inside the virtualenv with pipenv run. $ python -m pipenv shell Launching subshell in virtual environment... clear 创建结构文件__init__.py 测试 $ python -m pytest ============================================= test session starts ============================================= platform win32 -- Python 3.10.0, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 rootdir: D:\\gitlab\\gitlab_example_en collected 0 items / 1 error =================================================== ERRORS ==================================================== __________________________________ ERROR collecting tests/test_functions.py ___________________________________ ImportError while importing test module 'D:\\gitlab\\gitlab_example_en\\tests\\test_functions.py'. Hint: make sure your test modules/packages have valid Python names. Traceback: C:\\Python310\\lib\\importlib\\__init__.py:126: in import_module return _bootstrap._gcd_import(name[level:], package, level) tests\\test_functions.py:1: in from app.functions import sum E ImportError: cannot import name 'sum' from 'app.functions' (D:\\gitlab\\gitlab_example_en\\app\\functions.py) =========================================== short test summary info =========================================== ERROR tests/test_functions.py !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 error during collection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ============================================== 1 error in 0.14s =============================================== 没通过 修改内容 test_functions.py from app.functions import add def test_add(): assert add(1, 10) == 11 测试 $ python -m pytest ============================================= test session starts ============================================= platform win32 -- Python 3.10.0, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 rootdir: D:\\gitlab\\gitlab_example_en collected 1 item tests\\test_functions.py . [100%] ============================================== 1 passed in 0.03s ============================================== 测试通过 2.2 部署gitlab docker部署gitlab 配置本地与gitlab互信 登陆gitlab，创建一个空项目gitlab-example-demo 在vscode中的终端gitlab-example-en目录执行： $ git config --global user.name \"Administrator\" $ git config --global user.email \"admin@example.com\" $ ssh-keygen -t rsa -C \"admin@example.com\" $ cat /c/Users/XH/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCtv5pEPO+Esp14+bztwrq9dM4hD8rUF/Du/1tM6l2fKAgpmFoqM3OhMv9D/x7+94AL2+GUPJ5HPqbCDwzGRfUnLi02RnAHXij3+H/ZRzceCEBlCMvqx//+g/fmtYHdDxKlOcjfxlT4aAytKmRtpYPKIzzHd/lwMWtxpgHvnr+gOM6s67eVabOPlH6iyi7UyIoCy5Xg/wg5IDXFCSGfw3FSZS9EaDdWTTfntwGX7jnX3cEiY/kphKC7dvai3B/YUyx6ioZBgTeBN1aakMkaSiyRMEeQ4HmDI4QogiqHMgTNJCiUq5oiDf0JMwrW/m/IJnZemq4W1cheegaxvJKraJFWoIBp6/AOjisjZrMAbZbrpFDLzvsMJcqDgHSLjQd1hXMaLvR1K9JfYKwsjGzR8XaoKRW1742BbtqLq46qmzqW0pHpShGMmbeALAJMvjRqOG7MuTKcVe2CWyfX7QrIFxVucZ0tijlLMjuqZquUnVjsYm+SUujevm7h+IW09esL7j8= admin@example.com 赋值/c/Users/XH/.ssh/id_rsa.pub到gitlab的ssh_key,如图 2.3 项目上传gitlab 初始化本地项目，开始上传gitlab仓库 $ git init $ git commit -m \"add a new demo\" git remote add origin http://192.168.211.70:8081/root/gitlab-example-demo.git $ git push -u origin master Username for 'http://192.168.211.70:8081': root Password for 'http://root@192.168.211.70:8081': Enumerating objects: 7, done. Counting objects: 100% (7/7), done. Delta compression using up to 4 threads Compressing objects: 100% (5/5), done. Writing objects: 100% (7/7), 525 bytes | 262.00 KiB/s, done. Total 7 (delta 0), reused 0 (delta 0) To http://192.168.211.70:8081/root/gitlab-example-demo.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'origin'. 上传成功 2.4 编排.gitlab-ci.yaml 如果在gitlab运行自动化测试，需要用到.gitlab-ci.yaml，下面我们开始编写 $ cat .gitlab-ci.yaml stages: - test python_tests: image: python:3.9 stage: test script: - pip3 install pipenv $ git add . $ git commit -m \"add .gitlab-ci.yaml\" $ git push 当我们推送到gitlab发现项目无法运行自动测试。我们查明原因 2.5. 部署gitlab-runner 我们原来缺少一个 action runners，也就是gitlab-runner 官方安装gitlab-runner 我们可以用一个小的镜像gitlab/gitlab-runner:alpine-v14.4.2 docker run -d --name gitlab-runner --restart always --net=host \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:alpine-v14.4.2 注册runner $ docker run --rm -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=7 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://192.168.211.70:8081 Enter the registration token: 6D5mo8iWCLBaVdqcaqjN Enter a description for the runner: [329b671ffa00]: gitlab-example Enter tags for the runner (comma-separated): Registering runner... succeeded runner=6D5mo8iW Enter an executor: ssh, virtualbox, docker+machine, shell, docker-ssh+machine, kubernetes, custom, docker, docker-ssh, parallels: docker Enter the default Docker image (for example, ruby:2.6): ubuntu:20.04 Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 注册完成后，gitlab界面检查gitlab-runner是否注册成功 绿色代表成功，回到项目界面，已经开始在跑了。 2.6 测试跑起来 2.7 CI变得更安全 创建普通用户 apt-get update && apt-get upgrade useradd -m -s /bin/bash youtube passwd youtube usermod -aG sudo youtube 禁用关于root用户ssh的根访问 $ su - youtube $ vim /etc/ssh/sshd_config PermitRootLogin no $ systemctl restart ssh $ ssh root@192.168.211.70（拒绝） 安装Docker ssh-copy-id youtube@server-IP apt-get install -y docker.io #当前用户授权 usermod -aG docker $USER docker ps docker run hello-world 在youtube用户下重新运行部署新的gitlab-runner并注册，继续测试。 视频：https://mp.weixin.qq.com/s/NKgpZ1CCybkrNakZIlN-Ng 原创：https://www.youtube.com/watch?v=6QtJDaycUwA github：https://github.com/Ghostwritten/gitlab-example-demo.git 更多阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 07:25:08 "},"Gitlab/7_Gitlab_CI_CD.html":{"url":"Gitlab/7_Gitlab_CI_CD.html","title":"7 Gitlab CI CD","keywords":"","body":"Gitlab 编排 .gitlab-ci.yaml1. 快速构建.gitlab-ci.yaml2. python demo ci2.1 推送项目至gitlab2.2 安装gitlab-runner2.3 选择一个本地部署的需求Gitlab 编排 .gitlab-ci.yaml 1. 快速构建.gitlab-ci.yaml 创建一个项目 创建一个模板.gitlab-ci.yaml 选择Getting-started模板 stages: # List of stages for jobs, and their order of execution - build - test - deploy build-job: # This job runs in the build stage, which runs first. stage: build script: - echo \"Compiling the code...\" - echo \"Compile complete.\" unit-test-job: # This job runs in the test stage. stage: test # It only starts when the job in the build stage completes successfully. script: - echo \"Running unit tests... This will take about 60 seconds.\" - sleep 60 - echo \"Code coverage is 90%\" lint-test-job: # This job also runs in the test stage. stage: test # It can run at the same time as unit-test-job (in parallel). script: - echo \"Linting code... This will take about 10 seconds.\" - sleep 10 - echo \"No lint issues found.\" deploy-job: # This job runs in the deploy stage. stage: deploy # It only runs when *both* jobs in the test stage complete successfully. script: - echo \"Deploying application...\" - echo \"Application successfully deployed.\" 全部正常。 我们充分利用模板文件，可以为我们节省大量的时间。 2. python demo ci 使用flask快速搭建website 2.1 推送项目至gitlab 记录模块清单 pip freeze > requestments.txt git init git add . git commit -m \"add a new python demo\" git remote add origin root@gitlab.example.com:8081/root/flask_web1.git git push 2.2 安装gitlab-runner docker run -d --name gitlab-runner --restart always --net=host \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 2.3 选择一个本地部署的需求 我们就要为该项目注册shell运行的执行器的runner $ docker run --rm --net=host -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner:alpine-v14.4.2 register Runtime platform arch=amd64 os=linux pid=7 revision=50fc80a6 version=14.4.2 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): http://gitlab.example.com:8081 Enter the registration token: 8BxfhdBE2zf8NioR1UFE Enter a description for the runner: [yourdomain.com]: flask_demo Enter tags for the runner (comma-separated): python Registering runner... succeeded runner=8BxfhdBE Enter an executor: custom, parallels, docker+machine, kubernetes, docker, docker-ssh, shell, ssh, virtualbox, docker-ssh+machine: shell Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! 查看配置 $ cat /srv/gitlab-runner/config/config.toml concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = \"demo\" url = \"http://gitlab.example.com:8081/\" token = \"PF41kT9ZV_1DoT6VzcCu\" executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] tls_verify = false image = \"ubuntu:20.04\" dns = [\"8.8.8.8\", \"1.1.1.1\"] privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] extra_hosts = [\"gitlab.example.com:192.168.211.70\"] shm_size = 0 .......... [[runners]] name = \"flask_demo\" url = \"http://gitlab.example.com:8081\" token = \"tvCxfurs7EmRApH7un2a\" executor = \"shell\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] 为此项目注册runner，并不会影响其他项目的项目，因为配置是追加的。 选择一个最接近你的需求的、并修改量小的.gitlab-ci.yaml模板 修改.gitlab-ci.yaml 我的本地环境是ubuntu:8.04,本地可能没有flask，所以要在.gitlab-ci.yaml,装完就可以部署，两步走，即两个stage。 .gitlab-ci.yaml stages: - dep # List of stages for jobs, and their order of execution - deploy dep-job: stage: dep script: - apt -y install python3-pip - pip3 install flask deploy-job: # This job runs in the deploy stage. stage: deploy # It only runs when *both* jobs in the test stage complete successfully. script: - echo \"Deploying python flask demo application...\" - python3 app.py\" 创建一个Dockerfile模板 修改Dockerfile 更多阅读： 部署gitlab gitlab-runner部署 Gitlab 基础配置 Create a Continuous Integration (CI) Pipeline in Gitlab git与gitlab快速学习手册 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-06 04:47:59 "},"Overview.html":{"url":"Overview.html","title":"Overview","keywords":"","body":"Gitbook DocsGitbook Docs Git 1 Git Install 10 Git Skill 11 Git Practice 12 Git Set Upstream Branch 13 Git Fetch And Pull Difference 14 Git Fetch Prune 2 Git Process 3 Git Concept 4 Git Branch Management 5 Git View Commit History 6 Git Tag 7 Git Password Free Login 8 Git Rollback 9 Git Command Gitbook Plugins 1 Gitbook Plugin Summary 10 Gitbook Plugin Search 11 Gitbook Plugin Commment 12 Gitbook Plugin Copyright Notice 13 Gitbook Plugin Background 14 Gitbook Plugin Image View 15 Gitbook Plugin Icons And Logos 16 Gitbook Plugin Github 17 Gitbook Plugin Emoji 17 Gitbook Plugin Text Hiding 18 Gitbook Plugin TODO 19 Gitbook Plugin Page Editing 2 Gitbook Plugin Title Summary 20 Gitbook Plugin RSS 21 Gitbook Plugin Video 22 Gitbook Plugin SEO 23 Gitbook Plugin Statistics 24 Gitbook Plugin Navbor 25 Gitbook Plugin Theme 26 Gitbook Plugin Top Navigation 27 Gitbook Plugin Tags 28 Gitbook Plugin Pdf 29 Gitbook Plugin Readmore 3 Gitbook Plugin Side Navigation 30 Gitbook Plugin Music 4 Gitbook Plugin Directory Navigation 5 Gitbook Plugin Article TOC 6 Gitbook Plugin Tips And Emphasis 7 Gitbook Plugin Code Block 8 Gitbook Plugin Sharing 9 Gitbook Plugin Appreciate 1 Gitbook Get Started 2 Gitbook Install 3 Gitbook README 4 Gitbook SUMMARY 5_Gitbook_book.json 6 Gitbook Push Github Pages 7 Gitbook Update Github Pages Github 1 Github Create Depository 2 Github Local Pull Github 3 Github Manage Remote Repositories 4 Github Delete Folders Remotely 5 Github Delete Local And Remote Branches 6 Github Custom Home Page 7 Github Action Automatically Build Deploy 8 Github Open Source Merge Request Gitlab 1 Gitlab Get Started 2 Gitlab Install 3 Gitlab Config 4 Gitlab Runner Install 5 Gitlab Runner Management 6 Gitlab Create CI Pipeline 7 Gitlab CI CD Overview Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2023-02-22 09:46:36 "}}